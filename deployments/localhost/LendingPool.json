{
  "address": "0x809d550fca64d94Bd9F66E60752A544199cfAC3D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "enum LibFacet.InterestRateMode",
          "name": "_rateMode",
          "type": "uint8"
        }
      ],
      "name": "borrow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_useAsCollateral",
          "type": "bool"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_collateral",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_userToLiquidate",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_purchaseAmount",
          "type": "uint256"
        }
      ],
      "name": "liquidationCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "redeem",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "repay",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_useAsCollateral",
          "type": "bool"
        }
      ],
      "name": "setUserUsePoolAsCollateral",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x49ac0cb41c80d26eec4cbfb05dc27e1eb19026f11c185e3053030778c8150d0e",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x809d550fca64d94Bd9F66E60752A544199cfAC3D",
    "transactionIndex": 0,
    "gasUsed": "1611622",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7410fca0b7f9fe2708d989c41e5b6d2b164ff60c3ab40be8cf35277d081ce54e",
    "transactionHash": "0x49ac0cb41c80d26eec4cbfb05dc27e1eb19026f11c185e3053030778c8150d0e",
    "logs": [],
    "blockNumber": 396,
    "cumulativeGasUsed": "1611622",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "827d2890bced3c86a2ad1b35f517b9ae",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum LibFacet.InterestRateMode\",\"name\":\"_rateMode\",\"type\":\"uint8\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useAsCollateral\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userToLiquidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_purchaseAmount\",\"type\":\"uint256\"}],\"name\":\"liquidationCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_useAsCollateral\",\"type\":\"bool\"}],\"name\":\"setUserUsePoolAsCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lendingpool/LendingPool.sol\":\"LendingPool\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x4ffc0547c02ad22925310c585c0f166f8759e2648a09e9b489100c42f15dd98d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/lendingpool/DataProvider.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/LibFacet.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract DataProvider {\\n    using WadRayMath for uint256;\\n\\n    struct GetUserGlobalDataVars {\\n        uint256 compoundedLiquidityBalance;\\n        uint256 compoundedBorrowBalance;\\n        uint256 originationFee;\\n        uint256 reserveDecimals;\\n        uint256 baseLTV;\\n        uint256 liquidationThreshold;\\n        uint256 tokenUnit;\\n        uint256 poolUnitPrice;\\n        uint256 liquidityBalanceETH;\\n        bool userUsesReserveAsCollateral;\\n        bool usageAsCollateralEnabled;\\n    }\\n\\n    /// @dev get user data accross all pools\\n    function getUserGlobalData(address _user)\\n        public\\n        view\\n        returns (\\n            uint256 totalLiquidityBalanceETH,\\n            uint256 totalCollateralBalanceETH,\\n            uint256 totalBorrowBalanceETH,\\n            uint256 totalFeesETH,\\n            uint256 currentLTV,\\n            uint256 currentLiquidationThreshold,\\n            uint256 healthFactor,\\n            bool healthFactorBelowThreshold\\n        )\\n    {\\n        GetUserGlobalDataVars memory vars;\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        address[] memory pools = LibFacet.lpcStorage().allPools;\\n\\n        for (uint256 poolIdx = 0; poolIdx < pools.length; poolIdx++) {\\n            (\\n                vars.compoundedLiquidityBalance,\\n                vars.compoundedBorrowBalance,\\n                vars.originationFee,\\n                vars.userUsesReserveAsCollateral\\n            ) = core.getUserBasicPoolData(pools[poolIdx], _user);\\n\\n            if (\\n                vars.compoundedBorrowBalance == 0 &&\\n                vars.compoundedLiquidityBalance == 0\\n            ) continue;\\n\\n            (\\n                vars.reserveDecimals,\\n                vars.baseLTV,\\n                vars.liquidationThreshold,\\n                vars.usageAsCollateralEnabled\\n            ) = core.getPoolConfiguration(pools[poolIdx]);\\n\\n            vars.tokenUnit = 10**vars.reserveDecimals;\\n            vars.poolUnitPrice = LibFacet.getPriceFeed().getAssetPrice(\\n                pools[poolIdx]\\n            );\\n\\n            if (vars.compoundedLiquidityBalance > 0) {\\n                vars.liquidityBalanceETH =\\n                    (vars.poolUnitPrice * vars.compoundedLiquidityBalance) /\\n                    vars.tokenUnit;\\n                /// @dev totalLiquidityBalanceETH is the equivalent asset in US dollars. So 0.5 compoundedLiquidityBalance will yield 750 totalLiquidtiyBalacneETH if price for 1 ETH = 1500\\n                totalLiquidityBalanceETH += vars.liquidityBalanceETH;\\n\\n                if (\\n                    vars.usageAsCollateralEnabled &&\\n                    vars.userUsesReserveAsCollateral\\n                ) {\\n                    totalCollateralBalanceETH += vars.liquidityBalanceETH;\\n                    currentLTV += vars.liquidityBalanceETH * vars.baseLTV;\\n                    currentLiquidationThreshold +=\\n                        vars.liquidityBalanceETH *\\n                        vars.liquidationThreshold;\\n                }\\n            }\\n\\n            if (vars.compoundedBorrowBalance > 0) {\\n                totalBorrowBalanceETH +=\\n                    (vars.poolUnitPrice * vars.compoundedBorrowBalance) /\\n                    vars.tokenUnit;\\n                totalFeesETH +=\\n                    (vars.originationFee * vars.poolUnitPrice) /\\n                    vars.tokenUnit;\\n            }\\n        }\\n\\n        /// TODO: aren't the currentLTV and currentLiquidationThreshold always equal to baseLTV and liquidationThreshold?\\n        currentLTV = totalCollateralBalanceETH > 0\\n            ? currentLTV / totalCollateralBalanceETH\\n            : 0;\\n        currentLiquidationThreshold = totalCollateralBalanceETH > 0\\n            ? currentLiquidationThreshold / totalCollateralBalanceETH\\n            : 0;\\n        healthFactor = calculateHealthFactorFromBalances(\\n            totalCollateralBalanceETH,\\n            totalBorrowBalanceETH,\\n            totalFeesETH,\\n            currentLiquidationThreshold\\n        );\\n        healthFactorBelowThreshold = healthFactor < 1e18;\\n    }\\n\\n    function calculateExpectedVariableBorrowRate(address _pool, uint256 _amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        (uint256 variableBorrowRate, ) = LendingPoolCore(address(this))\\n            .calculateInterestRates(\\n                pool.providedLiquidity - _amount,\\n                pool.borrowedLiquidity + _amount,\\n                pool.rates.interestRateSlopeBelow,\\n                pool.rates.interestRateSlopeAbove,\\n                pool.rates.baseVariableBorrowRate,\\n                pool.rates.targetUtilisationRate\\n            );\\n        return variableBorrowRate / 10**7;\\n    }\\n\\n    function getUserPoolData(address _pool, address _user)\\n        public\\n        view\\n        returns (\\n            uint256 currentBorrowBalance,\\n            uint256 principalBorrowBalance,\\n            uint256 liquidityRate,\\n            uint256 originationFee,\\n            uint256 variableBorrowIndex,\\n            uint256 lastUpdatedTimestamp,\\n            LibFacet.InterestRateMode borrowRateMode,\\n            bool usageAsCollateralEnabled\\n        )\\n    {\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        (principalBorrowBalance, currentBorrowBalance, ) = core\\n            .getUserBorrowBalances(_pool, _user);\\n        borrowRateMode = core.getUserCurrentBorrowRateMode(_pool, _user);\\n        liquidityRate = core.getPoolLiquidityRate(_pool);\\n        originationFee = core.getUserOriginationFee(_pool, _user);\\n        variableBorrowIndex = core.getUserVariableBorrowIndex(_pool, _user);\\n        lastUpdatedTimestamp = core.getUserLastUpdatedTimestamp(_pool, _user);\\n        usageAsCollateralEnabled = core.getUserUsePoolAsCollateral(\\n            _pool,\\n            _user\\n        );\\n    }\\n\\n    function getUserRewardShare(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 liquidityProvidedByUser = LibFacet\\n            .lpcStorage()\\n            .pools[_pool]\\n            .users[_user]\\n            .liquidityProvided;\\n        if (liquidityProvidedByUser == 0) return 0;\\n\\n        uint256 totalLiquidityProvided = 0;\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        for (uint256 userIdx = 0; userIdx < pool.allUsers.length; userIdx++)\\n            totalLiquidityProvided += pool\\n                .users[pool.allUsers[userIdx]]\\n                .liquidityProvided;\\n\\n        return liquidityProvidedByUser.wadDiv(totalLiquidityProvided);\\n    }\\n\\n    function getAllActivePools() external view returns (address[] memory) {\\n        address[] memory allPools = LibFacet.lpcStorage().allPools;\\n        address[] memory activePools = new address[](allPools.length);\\n        uint256 activePoolIndex = 0;\\n        for (uint256 i = 0; i < allPools.length; i++) {\\n            if (LibFacet.lpcStorage().pools[allPools[i]].isActive)\\n                activePools[activePoolIndex++] = allPools[i];\\n        }\\n\\n        return activePools;\\n    }\\n\\n    function getAllActivePoolAssetNames()\\n        external\\n        view\\n        returns (string[] memory)\\n    {\\n        address[] memory allPools = LibFacet.lpcStorage().allPools;\\n        string[] memory activePools = new string[](allPools.length);\\n        uint256 activePoolIndex = 0;\\n        for (uint256 i = 0; i < allPools.length; i++) {\\n            if (LibFacet.lpcStorage().pools[allPools[i]].isActive)\\n                activePools[activePoolIndex++] = LibFacet\\n                    .lpcStorage()\\n                    .pools[allPools[i]]\\n                    .asset;\\n        }\\n\\n        return activePools;\\n    }\\n\\n    function getPoolDisplayData(address _pool, address _user)\\n        external\\n        view\\n        returns (LibFacet.getPoolDisplayDataLocalVars memory)\\n    {\\n        return\\n            LendingPoolCore(address(this)).getPoolDisplayInformation(\\n                _pool,\\n                _user\\n            );\\n    }\\n\\n    function calculateUserAmountToRepay(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        (, uint256 compoundedBorrowBalance, ) = LendingPoolCore(address(this))\\n            .getUserBorrowBalances(_pool, _user);\\n        uint256 originationFee = FeeProvider(address(this))\\n            .calculateLoanOriginationFee(compoundedBorrowBalance);\\n\\n        return compoundedBorrowBalance + originationFee;\\n    }\\n\\n    function getPoolLendData(address _pool, address _user)\\n        external\\n        view\\n        returns (\\n            string memory asset,\\n            uint256 depositedLiquidity,\\n            uint256 userDepositedLiquidity,\\n            uint256 userMaxRedeemAmount,\\n            uint256 borrowedLiquidity,\\n            uint256 depositAPY,\\n            uint256 loanToValue,\\n            bool isUsableAsCollateral\\n        )\\n    {\\n        (\\n            asset,\\n            depositedLiquidity,\\n            userDepositedLiquidity,\\n            borrowedLiquidity,\\n            loanToValue,\\n            isUsableAsCollateral\\n        ) = LendingPoolCore(address(this)).getPoolDepositInformation(\\n            _pool,\\n            _user\\n        );\\n        depositAPY = LendingPoolCore(address(this)).calculateUserDepositAPY(\\n            _pool\\n        );\\n        userMaxRedeemAmount = LendingPoolCore(address(this))\\n            .getUserMaxRedeemAmount(_pool, _user);\\n    }\\n\\n    function calculateHealthFactorFromBalances(\\n        uint256 _totalCollateralBalanceETH,\\n        uint256 _totalBorrowBalanceETH,\\n        uint256 _totalFeesETH,\\n        uint256 _currentLiquidationThreshold\\n    ) internal pure returns (uint256) {\\n        if (_totalBorrowBalanceETH == 0) return type(uint256).max;\\n\\n        return\\n            ((_totalCollateralBalanceETH * _currentLiquidationThreshold) / 100)\\n                .wadDiv(_totalBorrowBalanceETH + _totalFeesETH);\\n    }\\n\\n    function calculateAvailableBorrowsETH(address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        (\\n            ,\\n            uint256 collateralBalanceETH,\\n            uint256 borrowBalanceETH,\\n            uint256 totalFeesETH,\\n            uint256 LTV,\\n            ,\\n            ,\\n\\n        ) = getUserGlobalData(_user);\\n\\n        return\\n            calculateAvailableBorrowsETHInternal(\\n                collateralBalanceETH,\\n                borrowBalanceETH,\\n                totalFeesETH,\\n                LTV\\n            );\\n    }\\n\\n    function calculateAvailableBorrowsETHInternal(\\n        uint256 _collateralBalanceETH,\\n        uint256 _borrowBalanceETH,\\n        uint256 _totalFeesETH,\\n        uint256 _LTV\\n    ) internal view returns (uint256) {\\n        uint256 availableBorrowsETH = (_collateralBalanceETH * _LTV) / 100;\\n        if (availableBorrowsETH <= _borrowBalanceETH) return 0;\\n\\n        availableBorrowsETH -= _borrowBalanceETH + _totalFeesETH;\\n\\n        uint256 originationFee = FeeProvider(address(this))\\n            .calculateLoanOriginationFee(availableBorrowsETH);\\n        return availableBorrowsETH - originationFee;\\n    }\\n\\n    function calculateCollateralNeededInETH(\\n        address _pool,\\n        uint256 _amount,\\n        uint256 _fee,\\n        uint256 _userCurrentBorrowBalanceETH,\\n        uint256 _userCurrentFeesETH,\\n        uint256 _userCurrentLTV\\n    ) external view returns (uint256 collateralNeededInETH) {\\n        PriceFeed pf = LibFacet.getPriceFeed();\\n\\n        uint256 poolDecimals = LendingPoolCore(address(this)).getPoolDecimals(\\n            _pool\\n        );\\n        uint256 requestedBorrowAmountETH = (pf.getAssetPrice(_pool) *\\n            (_amount + _fee)) / 10**poolDecimals;\\n        collateralNeededInETH =\\n            ((_userCurrentBorrowBalanceETH +\\n                _userCurrentFeesETH +\\n                requestedBorrowAmountETH) * 100) /\\n            _userCurrentLTV;\\n    }\\n\\n    function getPoolAmountInETH(address _pool, uint256 _amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 decimals = LendingPoolCore(address(this)).getPoolDecimals(\\n            _pool\\n        );\\n        return\\n            (LibFacet.getPriceFeed().getAssetPrice(_pool) * _amount) /\\n            (10**decimals);\\n    }\\n\\n    function getMaxAmountToRepayOnLiquidation(\\n        address _pool,\\n        address _userToLiquidate\\n    ) public view returns (uint256 maxPrincipalAmount) {\\n        (, uint256 compoundedBorrowBalance, ) = LendingPoolCore(address(this))\\n            .getUserBorrowBalances(_pool, _userToLiquidate);\\n        return compoundedBorrowBalance / 2;\\n    }\\n\\n    function calculateAvailableCollateralToLiquidate(\\n        address _principal,\\n        address _collateral,\\n        uint256 _purchaseAmount,\\n        uint256 _userCollateralBalance\\n    ) public view returns (uint256 collateralAmount, uint256 principalAmount) {\\n        PriceFeed pf = LibFacet.getPriceFeed();\\n        uint256 principalPrice = pf.getAssetPrice(_principal);\\n        uint256 collateralPrice = pf.getAssetPrice(_collateral);\\n        uint256 liquidationBonus = LendingPoolCore(address(this))\\n            .getPoolLiquidationBonus(_collateral);\\n        uint256 maxCollateralToLiquidate = ((_purchaseAmount * principalPrice) /\\n            collateralPrice);\\n        maxCollateralToLiquidate +=\\n            (maxCollateralToLiquidate * liquidationBonus) /\\n            100;\\n        if (maxCollateralToLiquidate > _userCollateralBalance) {\\n            collateralAmount = _userCollateralBalance;\\n            principalAmount = ((collateralAmount * collateralPrice) /\\n                principalPrice);\\n            principalAmount -= (principalAmount * liquidationBonus) / 100;\\n        } else {\\n            collateralAmount = maxCollateralToLiquidate;\\n            principalAmount = _purchaseAmount;\\n        }\\n    }\\n\\n    function getUserCollateralAmount(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LendingPoolCore(address(this)).getUserCollateralBalance(\\n                _pool,\\n                _user\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xc4d06800b79fd883f99d6c44dec1dfaf788c06f12fd3a1f59a99756a6bc460e4\",\"license\":\"No-License\"},\"contracts/lendingpool/FeeProvider.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/WadRayMath.sol\\\";\\n\\ncontract FeeProvider {\\n    using WadRayMath for uint256;\\n\\n    uint256 internal constant originationFeePercentage = 0.0025 * 1e18;\\n\\n    function calculateLoanOriginationFee(uint256 _amount)\\n        external\\n        pure\\n        returns (uint256)\\n    {\\n        return _amount.wadMul(originationFeePercentage);\\n    }\\n}\\n\",\"keccak256\":\"0x365cb4d1455783a5d05b8e1ca78e930be14b795326c9839bb519375d55bf613f\",\"license\":\"No-License\"},\"contracts/lendingpool/LendingPool.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../libraries/LibFacet.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract LendingPool {\\n    using WadRayMath for uint256;\\n\\n    function deposit(\\n        address _pool,\\n        uint256 _amount,\\n        bool _useAsCollateral\\n    ) external payable {\\n        require(\\n            _pool == LibFacet.facetStorage().ethAddress\\n                ? msg.sender.balance >= _amount\\n                : ERC20(_pool).balanceOf(msg.sender) >= _amount,\\n            \\\"Insufficient token balance.\\\"\\n        );\\n\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n\\n        core.updateStateOnDeposit(_pool, msg.sender, _amount, _useAsCollateral);\\n\\n        core.transferToPool(_pool, msg.sender, _amount);\\n    }\\n\\n    function redeem(address _pool, uint256 _amount) external {\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        require(\\n            core.getPoolAvailableLiquidity(_pool) >= _amount,\\n            \\\"There is not enough liquidity available to redeem.\\\"\\n        );\\n        require(\\n            _amount <= core.getUserMaxRedeemAmount(_pool, msg.sender),\\n            \\\"User cannot redeem more than the accumulated interest.\\\"\\n        );\\n        core.updateStateOnRedeem(\\n            _pool,\\n            msg.sender,\\n            _amount,\\n            _amount == core.getUserMaxRedeemAmount(_pool, msg.sender)\\n        );\\n        core.transferToUser(_pool, msg.sender, _amount);\\n    }\\n\\n    struct BorrowLocalVars {\\n        uint256 principalBorrowBalance;\\n        uint256 currentLTV;\\n        uint256 currentLiquidationThreshold;\\n        uint256 borrowFee;\\n        uint256 requestedBorrowAmountETH;\\n        uint256 amountOfCollateralNeededETH;\\n        uint256 userCollateralBalanceETH;\\n        uint256 userBorrowBalanceETH;\\n        uint256 userTotalFeesETH;\\n        uint256 borrowBalanceIncrease;\\n        uint256 currentReserveStableRate;\\n        uint256 availableLiquidity;\\n        uint256 reserveDecimals;\\n        uint256 finalUserBorrowRate;\\n        LibFacet.InterestRateMode rateMode;\\n        bool healthFactorBelowThreshold;\\n    }\\n\\n    function borrow(\\n        address _pool,\\n        uint256 _amount,\\n        LibFacet.InterestRateMode _rateMode\\n    ) external {\\n        BorrowLocalVars memory vars;\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        require(\\n            core.isPoolBorrowingEnabled(_pool),\\n            \\\"Pool is not enabled for borrowing.\\\"\\n        );\\n        require(\\n            _rateMode == LibFacet.InterestRateMode.VARIABLE ||\\n                _rateMode == LibFacet.InterestRateMode.STABLE,\\n            \\\"Invalid interest rate mode selected\\\"\\n        );\\n        require(\\n            core.getPoolAvailableLiquidity(_pool) >= _amount,\\n            \\\"There is not enough liquidity available in the pool.\\\"\\n        );\\n\\n        (\\n            ,\\n            vars.userCollateralBalanceETH,\\n            vars.userBorrowBalanceETH,\\n            vars.userTotalFeesETH,\\n            vars.currentLTV,\\n            vars.currentLiquidationThreshold,\\n            ,\\n            vars.healthFactorBelowThreshold\\n        ) = DataProvider(address(this)).getUserGlobalData(msg.sender);\\n\\n        require(\\n            vars.userCollateralBalanceETH > 0,\\n            \\\"The collateral balance is 0.\\\"\\n        );\\n        require(\\n            !vars.healthFactorBelowThreshold,\\n            \\\"The borrower can already be liquidated.\\\"\\n        );\\n\\n        vars.borrowFee = FeeProvider(address(this)).calculateLoanOriginationFee(\\n            _amount\\n        );\\n\\n        require(vars.borrowFee > 0, \\\"The amount to borrow is too small.\\\");\\n\\n        vars.amountOfCollateralNeededETH = DataProvider(address(this))\\n            .calculateCollateralNeededInETH(\\n                _pool,\\n                _amount,\\n                vars.borrowFee,\\n                vars.userBorrowBalanceETH,\\n                vars.userTotalFeesETH,\\n                vars.currentLTV\\n            );\\n\\n        require(\\n            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\\n            \\\"Insufficient collateral to cover a new borrow.\\\"\\n        );\\n\\n        /// TODO: add stable rate checks\\n        core.updateStateOnBorrow(\\n            _pool,\\n            msg.sender,\\n            _amount,\\n            vars.borrowFee,\\n            vars.rateMode\\n        );\\n\\n        core.transferToUser(_pool, msg.sender, _amount);\\n    }\\n\\n    struct RepayLocalVars {\\n        uint256 principalBorrowBalance;\\n        uint256 compoundedBorrowBalance;\\n        uint256 borrowBalanceIncrease;\\n        bool isETH;\\n        uint256 paybackAmount;\\n        uint256 paybackAmountMinusFee;\\n        uint256 currentStableRate;\\n        uint256 originationFee;\\n    }\\n\\n    function repay(address _pool, uint256 _amount) external payable {\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        RepayLocalVars memory vars;\\n\\n        (\\n            vars.principalBorrowBalance,\\n            vars.compoundedBorrowBalance,\\n            vars.borrowBalanceIncrease\\n        ) = core.getUserBorrowBalances(_pool, msg.sender);\\n\\n        vars.originationFee = core.getUserOriginationFee(_pool, msg.sender);\\n        vars.isETH = LibFacet.facetStorage().ethAddress == _pool;\\n\\n        require(\\n            vars.compoundedBorrowBalance > 0,\\n            \\\"The user does not have any borrow pending.\\\"\\n        );\\n\\n        vars.paybackAmount = vars.compoundedBorrowBalance + vars.originationFee;\\n        if (_amount < vars.paybackAmount) vars.paybackAmount = _amount;\\n\\n        require(\\n            !vars.isETH || msg.value >= vars.paybackAmount,\\n            \\\"Insufficient msg.value send for the repayment.\\\"\\n        );\\n\\n        if (vars.paybackAmount <= vars.originationFee) {\\n            core.updateStateOnRepay(\\n                _pool,\\n                msg.sender,\\n                0,\\n                vars.paybackAmount,\\n                vars.borrowBalanceIncrease,\\n                false\\n            );\\n            core.transferToFeeCollector{\\n                value: vars.isETH ? vars.paybackAmount : 0\\n            }(_pool, msg.sender, vars.paybackAmount);\\n            return;\\n        }\\n\\n        vars.paybackAmountMinusFee = vars.paybackAmount - vars.originationFee;\\n\\n        core.updateStateOnRepay(\\n            _pool,\\n            msg.sender,\\n            vars.paybackAmountMinusFee,\\n            vars.originationFee,\\n            vars.borrowBalanceIncrease,\\n            vars.compoundedBorrowBalance == vars.paybackAmountMinusFee\\n        );\\n\\n        if (vars.originationFee > 0) {\\n            core.transferToFeeCollector{\\n                value: vars.isETH ? vars.originationFee : 0\\n            }(_pool, msg.sender, vars.originationFee);\\n        }\\n\\n        core.transferToPool(_pool, msg.sender, vars.paybackAmountMinusFee);\\n    }\\n\\n    function setUserUsePoolAsCollateral(address _pool, bool _useAsCollateral)\\n        external\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        require(\\n            pool.users[msg.sender].liquidityProvided > 0,\\n            \\\"User does not have any liquidity deposited.\\\"\\n        );\\n        require(\\n            !pool.users[msg.sender].useAsCollateral,\\n            \\\"User deposit is already used as collateral.\\\"\\n        );\\n        LendingPoolCore(address(this)).setUserUsePoolAsCollateralInternal(\\n            _pool,\\n            msg.sender,\\n            _useAsCollateral\\n        );\\n    }\\n\\n    struct liquidationCallLocalVars {\\n        uint256 userCollateralBalance;\\n        uint256 compoundedBalance;\\n        uint256 balanceIncrease;\\n        uint256 maxAmountToRepay;\\n        uint256 actualAmountToRepay;\\n        uint256 maxCollateralToLiquidate;\\n        uint256 principalAmountNeeded;\\n        uint256 originationFee;\\n        uint256 feeCollateralToLiquidate;\\n        uint256 feePrincipalAmountNeeded;\\n        bool healthFactorBelowThreshold;\\n    }\\n\\n    function liquidationCall(\\n        address _pool,\\n        address _collateral,\\n        address _userToLiquidate,\\n        uint256 _purchaseAmount\\n    ) external payable {\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        liquidationCallLocalVars memory vars;\\n        /// @TODO: uncomment after testing\\n        //(, , , , , , , vars.healthFactorBelowThreshold) = DataProvider(\\n        //    address(this)\\n        //).getUserGlobalData(_userToLiquidate);\\n        //require(vars.healthFactorBelowThreshold, \\\"User cannot be liquidated.\\\");\\n\\n        vars.userCollateralBalance = core.getUserCollateralBalance(\\n            _collateral,\\n            _userToLiquidate\\n        );\\n        require(\\n            vars.userCollateralBalance > 0,\\n            \\\"User has not provided collateral in the desired currency.\\\"\\n        );\\n\\n        (, vars.compoundedBalance, vars.balanceIncrease) = core\\n            .getUserBorrowBalances(_pool, _userToLiquidate);\\n        require(\\n            vars.compoundedBalance > 0,\\n            \\\"User has not gotten a loan in this pool's currency.\\\"\\n        );\\n\\n        vars.maxAmountToRepay = vars.compoundedBalance / 2;\\n        vars.actualAmountToRepay = _purchaseAmount > vars.maxAmountToRepay\\n            ? vars.maxAmountToRepay\\n            : _purchaseAmount;\\n\\n        (\\n            vars.maxCollateralToLiquidate,\\n            vars.principalAmountNeeded\\n        ) = DataProvider(address(this)).calculateAvailableCollateralToLiquidate(\\n            _pool,\\n            _collateral,\\n            vars.actualAmountToRepay,\\n            vars.userCollateralBalance\\n        );\\n\\n        vars.actualAmountToRepay = vars.principalAmountNeeded <\\n            vars.actualAmountToRepay\\n            ? vars.principalAmountNeeded\\n            : vars.actualAmountToRepay;\\n\\n        vars.originationFee = core.getUserOriginationFee(\\n            _pool,\\n            _userToLiquidate\\n        );\\n        if (vars.originationFee > 0) {\\n            (\\n                vars.feeCollateralToLiquidate,\\n                vars.feePrincipalAmountNeeded\\n            ) = DataProvider(address(this))\\n                .calculateAvailableCollateralToLiquidate(\\n                    _collateral,\\n                    _pool,\\n                    vars.originationFee,\\n                    vars.userCollateralBalance - vars.originationFee\\n                );\\n        }\\n\\n        core.updateStateOnLiquidationCall(\\n            _pool,\\n            _collateral,\\n            _userToLiquidate,\\n            vars.actualAmountToRepay,\\n            vars.feePrincipalAmountNeeded,\\n            vars.maxCollateralToLiquidate,\\n            vars.balanceIncrease\\n        );\\n\\n        core.transferToUser(\\n            _collateral,\\n            msg.sender,\\n            vars.maxCollateralToLiquidate\\n        );\\n        core.transferToPool(_pool, msg.sender, vars.actualAmountToRepay);\\n        if (vars.originationFee > 0)\\n            core.transferToFeeCollector(\\n                _pool,\\n                msg.sender,\\n                vars.feePrincipalAmountNeeded\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x50d4b0bd0791fb6a7f7e9e965bb33538cc0872c5e0617ad1d0bbc108a0790842\",\"license\":\"No-License\"},\"contracts/lendingpool/LendingPoolCore.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"./DataProvider.sol\\\";\\nimport \\\"../libraries/LibFacet.sol\\\";\\nimport \\\"../libraries/WadRayMath.sol\\\";\\nimport \\\"../mocks/EthMock.sol\\\";\\nimport \\\"../mocks/UsdcMock.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n// @TODO rename _balanceIncrease to something like \\\"accumulatedInterest\\\"\\ncontract LendingPoolCore {\\n    using WadRayMath for uint256;\\n\\n    function getEthValue(address _token, uint256 _amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 loanToValue = LibFacet.lpcStorage().pools[_token].loanToValue;\\n        return ((_amount * loanToValue) / 100);\\n    }\\n\\n    function updateStateOnDeposit(\\n        address _pool,\\n        address _user,\\n        uint256 _amount,\\n        bool _useAsCollateral\\n    ) public {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        updateCumulativeIndexes(pool);\\n        updatePoolInterestRates(pool, _amount, 0);\\n        bool isFirstDeposit = pool.users[_user].liquidityProvided == 0;\\n        pool.providedLiquidity += _amount;\\n        pool.users[_user].liquidityProvided += _amount;\\n        setUserUsePoolAsCollateralInternal(_pool, _user, _useAsCollateral);\\n        if (isFirstDeposit) {\\n            pool.allUsers.push(_user);\\n            initializeUserData(pool.users[_user]);\\n        }\\n    }\\n\\n    function updateStateOnRedeem(\\n        address _pool,\\n        address _user,\\n        uint256 _amount,\\n        bool _userRedeemedEverything\\n    ) public {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        updateCumulativeIndexes(pool);\\n\\n        uint256 liquidityProvided = pool.users[_user].liquidityProvided;\\n        if (_amount > liquidityProvided) {\\n            updatePoolInterestRates(pool, 0, liquidityProvided);\\n            pool.users[_user].liquidityProvided = 0;\\n            pool.providedLiquidity -= liquidityProvided;\\n            pool.rewardsLiquidity -= (_amount - liquidityProvided);\\n        } else {\\n            updatePoolInterestRates(pool, 0, _amount);\\n            pool.providedLiquidity -= _amount;\\n            pool.users[_user].liquidityProvided -= _amount;\\n        }\\n\\n        if (_userRedeemedEverything) {\\n            setUserUsePoolAsCollateralInternal(_pool, _user, false);\\n            pool.users[_user].rates.variableBorrowRate = 0;\\n            pool.users[_user].rates.stableBorrowRate = 0;\\n            pool.users[_user].rates.stableBorrowRate = 0;\\n            pool.users[_user].rates.cumulatedVariableBorrowIndex =\\n                1 *\\n                WadRayMath.RAY;\\n        }\\n    }\\n\\n    function updateStateOnBorrow(\\n        address _pool,\\n        address _user,\\n        uint256 _amount,\\n        uint256 _borrowFee,\\n        LibFacet.InterestRateMode _rateMode\\n    ) public {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        LibFacet.UserPoolData storage user = pool.users[_user];\\n        (\\n            uint256 principalBorrowBalance,\\n            ,\\n            uint256 balanceIncrease\\n        ) = getUserBorrowBalances(_pool, _user);\\n\\n        updatePoolStateOnBorrow(\\n            pool,\\n            _user,\\n            principalBorrowBalance,\\n            balanceIncrease,\\n            _amount,\\n            _rateMode\\n        );\\n\\n        updateUserStateOnBorrow(\\n            pool,\\n            user,\\n            _amount,\\n            balanceIncrease,\\n            _borrowFee,\\n            _rateMode\\n        );\\n\\n        updatePoolInterestRates(pool, 0, _amount);\\n    }\\n\\n    function updateStateOnRepay(\\n        address _pool,\\n        address _user,\\n        uint256 _paybackAmountMinusFee,\\n        uint256 _originationFeeRepaid,\\n        uint256 _balanceIncrease,\\n        bool _repaidWholeLoan\\n    ) external {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n\\n        updatePoolStateOnRepay(\\n            pool,\\n            _pool,\\n            _user,\\n            _paybackAmountMinusFee,\\n            _balanceIncrease\\n        );\\n        updateUserStateOnRepay(\\n            pool,\\n            _user,\\n            _paybackAmountMinusFee,\\n            _originationFeeRepaid,\\n            _balanceIncrease,\\n            _repaidWholeLoan\\n        );\\n\\n        updatePoolInterestRates(pool, _paybackAmountMinusFee, 0);\\n    }\\n\\n    function updateStateOnLiquidationCall(\\n        address _pool,\\n        address _collateral,\\n        address _user,\\n        uint256 _principalAmountToRepay,\\n        uint256 _feeRepayed,\\n        uint256 _collateralAmountToLiquidate,\\n        uint256 _balanceIncrease\\n    ) public {\\n        LibFacet.Pool storage principalPool = LibFacet.lpcStorage().pools[\\n            _pool\\n        ];\\n        LibFacet.Pool storage collateralPool = LibFacet.lpcStorage().pools[\\n            _collateral\\n        ];\\n\\n        updatePrincipalPoolStateOnLiquidationCall(\\n            principalPool,\\n            principalPool.users[_user],\\n            _principalAmountToRepay,\\n            _balanceIncrease\\n        );\\n        updateCumulativeIndexes(collateralPool);\\n        updateUserStateOnLiquidationCall(\\n            principalPool,\\n            collateralPool,\\n            _user,\\n            _principalAmountToRepay,\\n            _feeRepayed,\\n            _balanceIncrease,\\n            _collateralAmountToLiquidate\\n        );\\n        updatePoolInterestRates(principalPool, _principalAmountToRepay, 0);\\n        updatePoolInterestRates(\\n            collateralPool,\\n            0,\\n            _collateralAmountToLiquidate\\n        );\\n    }\\n\\n    function updateUserStateOnLiquidationCall(\\n        LibFacet.Pool storage _pool,\\n        LibFacet.Pool storage _collateral,\\n        address _user,\\n        uint256 _amountRepayed,\\n        uint256 _feeLiquidated,\\n        uint256 _balanceIncrease,\\n        uint256 _collateralToLiquidate\\n    ) internal {\\n        _collateral.users[_user].liquidityProvided -= _collateralToLiquidate;\\n        _pool.users[_user].principalBorrowBalance -=\\n            _amountRepayed -\\n            _balanceIncrease;\\n        _pool.users[_user].originationFee -= _feeLiquidated;\\n        if (\\n            _pool.users[_user].rates.rateMode ==\\n            LibFacet.InterestRateMode.VARIABLE\\n        )\\n            _pool.users[_user].cumulatedVariableBorrowIndex = _pool\\n                .cumulatedVariableBorrowIndex;\\n        _pool.users[_user].lastUpdatedTimestamp = block.timestamp;\\n    }\\n\\n    function updatePrincipalPoolStateOnLiquidationCall(\\n        LibFacet.Pool storage _pool,\\n        LibFacet.UserPoolData storage _user,\\n        uint256 _amountToRepay,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        console.log(_pool.borrowedLiquidity);\\n        console.log(_amountToRepay);\\n        console.log(_balanceIncrease);\\n        _pool.borrowedLiquidity -= _amountToRepay - _balanceIncrease;\\n        updateCumulativeIndexes(_pool);\\n        if (\\n            _user.rates.rateMode == LibFacet.InterestRateMode.STABLE\\n        ) {} else if (\\n            _user.rates.rateMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            increaseTotalVariableBorrows(_pool, _balanceIncrease);\\n            decreaseTotalVariableBorrows(_pool, _amountToRepay);\\n        }\\n    }\\n\\n    function updatePoolStateOnLiquidationCall(\\n        LibFacet.Pool storage _pool,\\n        uint256 _amount,\\n        uint256 _balanceIncrease,\\n        LibFacet.InterestRateMode _interestMode\\n    ) internal {\\n        updateCumulativeIndexes(_pool);\\n        _pool.providedLiquidity += _balanceIncrease;\\n        if (_interestMode == LibFacet.InterestRateMode.STABLE) {} else if (\\n            _interestMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            decreaseTotalVariableBorrows(_pool, _amount);\\n        }\\n    }\\n\\n    function updatePoolStateOnRepay(\\n        LibFacet.Pool storage _pool,\\n        address _poolAddress,\\n        address _user,\\n        uint256 _paybackAmountMinusFee,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        updateCumulativeIndexes(_pool);\\n        _pool.rewardsLiquidity += _balanceIncrease;\\n        _pool.borrowedLiquidity -= _paybackAmountMinusFee - _balanceIncrease;\\n\\n        LibFacet.InterestRateMode borrowMode = getUserCurrentBorrowRateMode(\\n            _poolAddress,\\n            _user\\n        );\\n        if (borrowMode == LibFacet.InterestRateMode.VARIABLE) {\\n            increaseTotalVariableBorrows(_pool, _balanceIncrease);\\n            decreaseTotalVariableBorrows(_pool, _paybackAmountMinusFee);\\n        } else {}\\n    }\\n\\n    function updateUserStateOnRepay(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _paybackAmountMinusFee,\\n        uint256 _originationFeeRepaid,\\n        uint256 _balanceIncrease,\\n        bool _repaidWholeLoan\\n    ) internal {\\n        LibFacet.UserPoolData storage user = _pool.users[_user];\\n        user.principalBorrowBalance -=\\n            _paybackAmountMinusFee -\\n            _balanceIncrease;\\n        user.cumulatedVariableBorrowIndex = _pool.cumulatedVariableBorrowIndex;\\n        if (_repaidWholeLoan) {\\n            user.rates.stableBorrowRate = 0;\\n            user.rates.variableBorrowRate = 0;\\n        }\\n        user.originationFee = user.originationFee - _originationFeeRepaid;\\n        user.lastUpdatedTimestamp = block.timestamp;\\n    }\\n\\n    function updatePoolStateOnBorrow(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _principalBorrowBalance,\\n        uint256 _balanceIncrease,\\n        uint256 _amountBorrowed,\\n        LibFacet.InterestRateMode _rateMode\\n    ) internal {\\n        updateCumulativeIndexes(_pool);\\n        updatePoolTotalBorrows(\\n            _pool,\\n            _user,\\n            _principalBorrowBalance,\\n            _balanceIncrease,\\n            _amountBorrowed,\\n            _rateMode\\n        );\\n        _pool.borrowedLiquidity += _amountBorrowed;\\n    }\\n\\n    // TODO: ADD previous values of indexes to the Pool and UserPoolData structs.\\n    function updateUserStateOnBorrow(\\n        LibFacet.Pool storage _pool,\\n        LibFacet.UserPoolData storage _user,\\n        uint256 _amountBorrowed,\\n        uint256 _balanceIncrease,\\n        uint256 _fee,\\n        LibFacet.InterestRateMode _rateMode\\n    ) internal {\\n        if (_rateMode == LibFacet.InterestRateMode.STABLE) {} else if (\\n            _rateMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            _user.rates.stableBorrowRate = 0;\\n            _user.cumulatedVariableBorrowIndex = _pool\\n                .cumulatedVariableBorrowIndex;\\n        } else {\\n            revert(\\\"Invalid borrow mode.\\\");\\n        }\\n\\n        _user.principalBorrowBalance += _balanceIncrease + _amountBorrowed;\\n        _user.originationFee = _user.originationFee + _fee;\\n        _user.lastUpdatedTimestamp = block.timestamp;\\n    }\\n\\n    function updatePoolTotalBorrows(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _principalBorrowBalance,\\n        uint256 _balanceIncrease,\\n        uint256 _amountBorrowed,\\n        LibFacet.InterestRateMode _newRateMode\\n    ) internal {\\n        LibFacet.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\\n                _pool.users[_user]\\n            );\\n        if (previousRateMode == LibFacet.InterestRateMode.STABLE) {} else if (\\n            previousRateMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            decreaseTotalVariableBorrows(_pool, _principalBorrowBalance);\\n        }\\n\\n        uint256 newPrincipalAmount = _principalBorrowBalance +\\n            _amountBorrowed +\\n            _balanceIncrease;\\n        if (_newRateMode == LibFacet.InterestRateMode.STABLE) {} else if (\\n            _newRateMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            increaseTotalVariableBorrows(_pool, newPrincipalAmount);\\n        } else {\\n            revert(\\\"Invalid new borrow rate mode.\\\");\\n        }\\n    }\\n\\n    function decreaseTotalVariableBorrows(\\n        LibFacet.Pool storage _pool,\\n        uint256 _amount\\n    ) internal {\\n        require(\\n            _pool.variableBorrowLiquidity >= _amount,\\n            \\\"The amount that is being subtracted from the variable borrows is incorrect.\\\"\\n        );\\n        _pool.variableBorrowLiquidity -= _amount;\\n    }\\n\\n    function increaseTotalVariableBorrows(\\n        LibFacet.Pool storage _pool,\\n        uint256 _amount\\n    ) internal {\\n        _pool.variableBorrowLiquidity += _amount;\\n    }\\n\\n    function getPoolLiquidityRate(address _pool) public view returns (uint256) {\\n        return LibFacet.lpcStorage().pools[_pool].rates.currentLiquidityRate;\\n    }\\n\\n    function getUserCurrentBorrowRateMode(LibFacet.UserPoolData memory _user)\\n        internal\\n        pure\\n        returns (LibFacet.InterestRateMode)\\n    {\\n        if (_user.principalBorrowBalance == 0)\\n            return LibFacet.InterestRateMode.NONE;\\n\\n        return\\n            _user.rates.stableBorrowRate > 0\\n                ? LibFacet.InterestRateMode.STABLE\\n                : LibFacet.InterestRateMode.VARIABLE;\\n    }\\n\\n    function updateCumulativeIndexes(LibFacet.Pool storage _pool) internal {\\n        if (_pool.borrowedLiquidity > 0) {\\n            _pool.cumulatedLiquidityIndex = calculateLinearInterest(\\n                _pool.rates.currentLiquidityRate,\\n                _pool.lastUpdatedTimestamp\\n            ).rayMul(_pool.cumulatedLiquidityIndex);\\n            _pool.cumulatedVariableBorrowIndex = calculateCompoundedInterest(\\n                _pool.rates.variableBorrowRate,\\n                LibFacet.SECONDS_IN_A_YEAR,\\n                block.timestamp,\\n                _pool.lastUpdatedTimestamp\\n            ).rayMul(_pool.cumulatedVariableBorrowIndex);\\n        }\\n    }\\n\\n    function updatePoolInterestRates(\\n        LibFacet.Pool storage _pool,\\n        uint256 _liquidityAdded,\\n        uint256 _liquidityTaken\\n    ) internal {\\n        (\\n            _pool.rates.variableBorrowRate,\\n            _pool.rates.currentLiquidityRate\\n        ) = calculateInterestRates(\\n            _pool.providedLiquidity + _liquidityAdded - _liquidityTaken,\\n            _pool.variableBorrowLiquidity,\\n            _pool.rates.interestRateSlopeBelow,\\n            _pool.rates.interestRateSlopeAbove,\\n            _pool.rates.baseVariableBorrowRate,\\n            _pool.rates.targetUtilisationRate\\n        );\\n        _pool.rates.overallBorrowRate = _pool.rates.variableBorrowRate;\\n        _pool.lastUpdatedTimestamp = block.timestamp;\\n    }\\n\\n    function calculateInterestRates(\\n        uint256 _totalLiquidity,\\n        uint256 _totalVariableBorrows,\\n        uint256 _variableRateSlope1,\\n        uint256 _variableRateSlope2,\\n        uint256 _baseVariableBorrowRate,\\n        uint256 _optimalUtilizationRate\\n    )\\n        public\\n        pure\\n        returns (\\n            uint256 currentVariableBorrowRate,\\n            uint256 currentLiquidityRate\\n        )\\n    {\\n        uint256 totalBorrows = _totalVariableBorrows; /// @dev + totalStableBorrows\\n        uint256 utilizationRate = (_totalLiquidity == 0 && totalBorrows == 0)\\n            ? 0\\n            : totalBorrows.rayDiv(_totalLiquidity + totalBorrows);\\n\\n        if (utilizationRate > _optimalUtilizationRate) {\\n            uint256 excessUtilizationRateRatio = (utilizationRate -\\n                _optimalUtilizationRate).rayDiv(\\n                    WadRayMath.RAY - _optimalUtilizationRate\\n                );\\n            currentVariableBorrowRate =\\n                _baseVariableBorrowRate +\\n                _variableRateSlope1 +\\n                (_variableRateSlope2.rayMul(excessUtilizationRateRatio));\\n        } else {\\n            currentVariableBorrowRate =\\n                _baseVariableBorrowRate +\\n                (\\n                    utilizationRate.rayDiv(_optimalUtilizationRate).rayMul(\\n                        _variableRateSlope1\\n                    )\\n                );\\n        }\\n        uint256 overallBorrowRate = calculateOverallBorrowRate(\\n            _totalVariableBorrows,\\n            currentVariableBorrowRate\\n        );\\n        currentLiquidityRate = overallBorrowRate.rayMul(utilizationRate);\\n    }\\n\\n    function calculateOverallBorrowRate(\\n        uint256 _totalVariableBorrows,\\n        uint256 _currentVariableBorrowRate\\n    ) internal pure returns (uint256) {\\n        uint256 totalBorrows = _totalVariableBorrows; /// TODO: + _totalStableBorrows\\n        if (totalBorrows == 0) return 0;\\n\\n        uint256 weightedVariableRate = _totalVariableBorrows.wadToRay().rayMul(\\n            _currentVariableBorrowRate\\n        );\\n\\n        return weightedVariableRate.rayDiv(totalBorrows.wadToRay());\\n    }\\n\\n    function getPoolLiquidationBonus(address _pool)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].liquidationBonus;\\n    }\\n\\n    function getUserBorrowBalances(address _pool, address _user)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        LibFacet.UserPoolData storage user = pool.users[_user];\\n        if (user.principalBorrowBalance == 0) return (0, 0, 0);\\n\\n        uint256 compoundedBalance = getCompoundedBorrowBalance(user, pool);\\n        return (\\n            user.principalBorrowBalance,\\n            compoundedBalance,\\n            compoundedBalance - user.principalBorrowBalance\\n        );\\n    }\\n\\n    function getUserOriginationFee(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].users[_user].originationFee;\\n    }\\n\\n    function calculateCompoundedInterest(\\n        uint256 _variableBorrowRate,\\n        uint256 _secondsInAYear,\\n        uint256 _timestamp,\\n        uint256 _lastUpdatedTimestamp\\n    ) public pure returns (uint256) {\\n        uint256 ratePerSecond = _variableBorrowRate / _secondsInAYear;\\n        return\\n            (WadRayMath.RAY + ratePerSecond).rayPow(\\n                _timestamp - _lastUpdatedTimestamp\\n            );\\n    }\\n\\n    /// @dev calculates interest using linear interest rate formula\\n    function calculateLinearInterest(\\n        uint256 _currentLiquidityRate,\\n        uint256 _lastUpdatedTimestamp\\n    ) internal view returns (uint256) {\\n        uint256 timeDelta = calculateTimeDelta(\\n            block.timestamp,\\n            _lastUpdatedTimestamp,\\n            LibFacet.SECONDS_IN_A_YEAR\\n        );\\n        return _currentLiquidityRate.rayMul(timeDelta) + WadRayMath.RAY;\\n    }\\n\\n    function calculateTimeDelta(\\n        uint256 _timestamp,\\n        uint256 _lastUpdatedTimestamp,\\n        uint256 _secondsInAYear\\n    ) internal pure returns (uint256) {\\n        return (_timestamp - _lastUpdatedTimestamp) / _secondsInAYear;\\n    }\\n\\n    function getCompoundedBorrowBalance(\\n        LibFacet.UserPoolData storage _user,\\n        LibFacet.Pool storage _pool\\n    ) internal view returns (uint256) {\\n        if (_user.principalBorrowBalance == 0) return 0;\\n\\n        uint256 principalBorrowBalance = _user\\n            .principalBorrowBalance\\n            .wadToRay();\\n        uint256 compoundedBalance = 0;\\n        uint256 cumulatedInterest = 0;\\n\\n        if (_user.rates.stableBorrowRate > 0) {} else {\\n            cumulatedInterest = calculateCompoundedInterest(\\n                _pool.rates.variableBorrowRate,\\n                LibFacet.SECONDS_IN_A_YEAR,\\n                block.timestamp,\\n                _pool.lastUpdatedTimestamp\\n            ).rayMul(_pool.cumulatedVariableBorrowIndex).rayDiv(\\n                    _user.cumulatedVariableBorrowIndex\\n                );\\n        }\\n\\n        compoundedBalance = principalBorrowBalance\\n            .rayMul(cumulatedInterest)\\n            .rayToWad();\\n\\n        return compoundedBalance;\\n    }\\n\\n    function getUserVariableBorrowIndex(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LibFacet\\n                .lpcStorage()\\n                .pools[_pool]\\n                .users[_user]\\n                .rates\\n                .variableBorrowRate;\\n    }\\n\\n    function getUserUsePoolAsCollateral(address _pool, address _user)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].users[_user].useAsCollateral;\\n    }\\n\\n    function getUserCurrentBorrowRate(\\n        LibFacet.Pool storage _pool,\\n        address _user\\n    ) internal view returns (uint256) {\\n        LibFacet.InterestRateMode rateMode = getUserCurrentBorrowRateMode(\\n            _pool.users[_user]\\n        );\\n\\n        if (rateMode == LibFacet.InterestRateMode.NONE) return 0;\\n\\n        return\\n            rateMode == LibFacet.InterestRateMode.STABLE\\n                ? 0\\n                : _pool.rates.variableBorrowRate;\\n    }\\n\\n    function getUserCurrentBorrowRateMode(address _pool, address _user)\\n        public\\n        view\\n        returns (LibFacet.InterestRateMode)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].users[_user].rates.rateMode;\\n    }\\n\\n    function getUserLastUpdatedTimestamp(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LibFacet\\n                .lpcStorage()\\n                .pools[_pool]\\n                .users[_user]\\n                .lastUpdatedTimestamp;\\n    }\\n\\n    function getUserBasicPoolData(address _pool, address _user)\\n        public\\n        view\\n        returns (\\n            uint256 compoundedLiquidityBalance,\\n            uint256 compoundedBorrowBalance,\\n            uint256 originationFee,\\n            bool userUsesPoolAsCollateral\\n        )\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        /// Q: How to compound the deposited balance? Don't return just the 'principal' amount.\\n        /// A: Store the compounded interest from loans and distribute it amongst the depositors based on their share.\\n        uint256 assetBalance = pool.users[_user].liquidityProvided;\\n        if (pool.users[_user].principalBorrowBalance == 0)\\n            return (assetBalance, 0, 0, pool.users[_user].useAsCollateral);\\n\\n        return (\\n            assetBalance,\\n            getCompoundedBorrowBalance(pool.users[_user], pool),\\n            pool.users[_user].originationFee,\\n            pool.users[_user].useAsCollateral\\n        );\\n    }\\n\\n    function getUserCumulatedRewards(\\n        address _pool,\\n        address _user,\\n        uint256 _totalRewards\\n    ) public view returns (uint256) {\\n        uint256 userShare = DataProvider(address(this)).getUserRewardShare(\\n            _pool,\\n            _user\\n        );\\n\\n        return (_totalRewards * userShare) / 10**18;\\n    }\\n\\n    function getPoolDepositInformation(address _pool, address _user)\\n        public\\n        view\\n        returns (\\n            string memory asset,\\n            uint256 depositedLiquidity,\\n            uint256 userDepositedLiquidity,\\n            uint256 borrowedLiquidity,\\n            uint256 loanToValue,\\n            bool isUsableAsCollateral\\n        )\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        return (\\n            pool.asset,\\n            pool.providedLiquidity,\\n            pool.users[_user].liquidityProvided,\\n            pool.borrowedLiquidity,\\n            pool.loanToValue,\\n            pool.isUsableAsCollateral\\n        );\\n    }\\n\\n    function getPoolDisplayInformation(address _pool, address _user)\\n        public\\n        view\\n        returns (LibFacet.getPoolDisplayDataLocalVars memory)\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        return\\n            LibFacet.getPoolDisplayDataLocalVars(\\n                pool.asset,\\n                pool.loanToValue,\\n                pool.liquidationThreshold,\\n                pool.liquidationBonus,\\n                pool.providedLiquidity,\\n                pool.borrowedLiquidity,\\n                pool.users[_user].principalBorrowBalance,\\n                DataProvider(address(this)).calculateUserAmountToRepay(\\n                    _pool,\\n                    _user\\n                ),\\n                pool.isBorrowingEnabled,\\n                pool.isUsableAsCollateral\\n            );\\n    }\\n\\n    function getPoolConfiguration(address _pool)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        return (\\n            pool.decimals,\\n            pool.baseLTV,\\n            pool.liquidationThreshold,\\n            pool.isUsableAsCollateral\\n        );\\n    }\\n\\n    function getPoolDecimals(address _pool) public view returns (uint256) {\\n        return LibFacet.lpcStorage().pools[_pool].decimals;\\n    }\\n\\n    function getUserMaxRedeemAmount(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            getUserCumulatedRewards(\\n                _pool,\\n                _user,\\n                LibFacet.lpcStorage().pools[_pool].rewardsLiquidity\\n            ) +\\n            LibFacet.lpcStorage().pools[_pool].users[_user].liquidityProvided;\\n    }\\n\\n    function getUserCollateralBalance(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LibFacet.lpcStorage().pools[_pool].users[_user].useAsCollateral\\n                ? LibFacet\\n                    .lpcStorage()\\n                    .pools[_pool]\\n                    .users[_user]\\n                    .liquidityProvided\\n                : 0;\\n    }\\n\\n    function getPoolCumulatedRewards(address _pool)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].rewardsLiquidity;\\n    }\\n\\n    function getPoolAvailableLiquidity(address _pool)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            LibFacet.lpcStorage().pools[_pool].providedLiquidity +\\n            LibFacet.lpcStorage().pools[_pool].rewardsLiquidity -\\n            LibFacet.lpcStorage().pools[_pool].borrowedLiquidity;\\n    }\\n\\n    function calculateUserDepositAPY(address _pool)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        if (pool.providedLiquidity == 0) return 0;\\n\\n        uint256 oneYearAhead = pool.lastUpdatedTimestamp + 365 days;\\n        uint256 cumulatedInterest = LendingPoolCore(address(this))\\n            .calculateCompoundedInterest(\\n                pool.rates.variableBorrowRate,\\n                LibFacet.SECONDS_IN_A_YEAR,\\n                oneYearAhead,\\n                pool.lastUpdatedTimestamp\\n            )\\n            .rayMul(pool.cumulatedVariableBorrowIndex);\\n        uint256 compoundedInterest = pool\\n            .borrowedLiquidity\\n            .wadToRay()\\n            .rayMul(cumulatedInterest)\\n            .rayToWad();\\n        uint256 cumulatedValue = compoundedInterest - pool.borrowedLiquidity;\\n\\n        return\\n            (pool.providedLiquidity + cumulatedValue).wadDiv(\\n                pool.providedLiquidity\\n            ) - WadRayMath.WAD;\\n    }\\n\\n    function isPoolBorrowingEnabled(address _pool) public view returns (bool) {\\n        return LibFacet.lpcStorage().pools[_pool].isBorrowingEnabled;\\n    }\\n\\n    function isPoolUsageAsCollateralEnabled(address _pool)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].isUsableAsCollateral;\\n    }\\n\\n    function setUserUsePoolAsCollateralInternal(\\n        address _pool,\\n        address _user,\\n        bool _useAsCollateral\\n    ) public {\\n        LibFacet\\n            .lpcStorage()\\n            .pools[_pool]\\n            .users[_user]\\n            .useAsCollateral = _useAsCollateral;\\n    }\\n\\n    function initializeUserData(LibFacet.UserPoolData storage _user) internal {\\n        _user.cumulatedVariableBorrowIndex = WadRayMath.RAY;\\n        _user.cumulatedVariableBorrowIndex = WadRayMath.RAY;\\n    }\\n\\n    function transferToPool(\\n        address _pool,\\n        address _user,\\n        uint256 _amount\\n    ) public payable {\\n        if (_pool == LibFacet.facetStorage().ethAddress) {\\n            (bool success, ) = _pool.call{value: _amount}(\\\"\\\");\\n            require(success, \\\"Error while sending ETH.\\\");\\n        } else {\\n            bool success = ERC20(_pool).transferFrom(_user, _pool, _amount);\\n            require(success, \\\"Error while sending ERC20 tokens to pool.\\\");\\n        }\\n    }\\n\\n    function transferToUser(\\n        address _pool,\\n        address _user,\\n        uint256 _amount\\n    ) public {\\n        if (_pool == LibFacet.facetStorage().ethAddress) {\\n            EthMock(payable(_pool)).transferEthToUser(_user, _amount);\\n        } else {\\n            UsdcMock(_pool).customApprove(\\n                _pool,\\n                LibFacet.facetStorage().diamondAddress,\\n                _amount\\n            );\\n            bool success = ERC20(_pool).transferFrom(_pool, _user, _amount);\\n            require(success, \\\"Error on sending ERC20 to user.\\\");\\n        }\\n    }\\n\\n    function transferToFeeCollector(\\n        address _token,\\n        address _user,\\n        uint256 _amount\\n    ) public payable {\\n        address feeProvider = LibFacet.facetStorage().feeProviderAddress;\\n        if (_token != LibFacet.facetStorage().ethAddress) {\\n            bool success = ERC20(_token).transferFrom(\\n                _user,\\n                feeProvider,\\n                _amount\\n            );\\n            require(success, \\\"Error on sending ERC20 tokens to fee collector.\\\");\\n        } else {\\n            (bool result, ) = feeProvider.call{value: _amount}(\\\"\\\");\\n            require(result, \\\"Transfer of ETH failed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6b96e2221a608a49c961b6b6c217974a0f3a848983b571c4bc84f00de7866d3b\",\"license\":\"No-License\"},\"contracts/libraries/LibFacet.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"../lendingpool/LendingPoolCore.sol\\\";\\nimport \\\"../lendingpool/DataProvider.sol\\\";\\nimport \\\"../lendingpool/FeeProvider.sol\\\";\\nimport \\\"../mocks/PriceFeed.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary LibFacet {\\n    uint256 internal constant SECONDS_IN_A_YEAR = 365 days;\\n    uint256 internal constant RATE_MULTIPLIER = 10**8;\\n    bytes32 internal constant LENDING_POOL_CORE_STORAGE_POSITION =\\n        keccak256(\\\"diamonds.standart.lending.pool.core.storage\\\");\\n    bytes32 internal constant FACET_STORAGE_POSITION =\\n        keccak256(\\\"diamonds.standart.facet.storage\\\");\\n\\n    // user data tied to a specific pool\\n    struct UserPoolData {\\n        uint256 liquidityProvided;\\n        uint256 principalBorrowBalance;\\n        uint256 compoundedBorrowBalance;\\n        uint256 cumulatedVariableBorrowIndex;\\n        uint256 lastCumulatedVariableBorrowIndex;\\n        uint256 collateralETHBalance;\\n        uint256 liquidationThreshold;\\n        uint256 originationFee;\\n        uint256 lastUpdatedTimestamp;\\n        bool useAsCollateral;\\n        UserInterestRate rates;\\n    }\\n\\n    struct Pool {\\n        string asset;\\n        uint256 decimals;\\n        uint256 providedLiquidity;\\n        uint256 borrowedLiquidity;\\n        uint256 rewardsLiquidity;\\n        uint256 variableBorrowLiquidity;\\n        uint256 cumulatedLiquidityIndex; // interest cumulated by the reserve during the time interval Dt\\n        uint256 reserveNormalizedIncome; // Ongoing interest cumulated by the reserve\\n        uint256 cumulatedVariableBorrowIndex;\\n        uint256 baseLTV;\\n        uint256 loanToValue;\\n        uint256 liquidationThreshold;\\n        uint256 liquidationBonus; // represented in percentage\\n        uint256 lastUpdatedTimestamp;\\n        bool isBorrowingEnabled;\\n        bool isUsableAsCollateral;\\n        bool isActive;\\n        bool isFreezed; // only allow repays and redeems, but not deposits, new borrowings or rate swap.\\n        InterestRate rates;\\n        address[] allUsers;\\n        mapping(address => UserPoolData) users;\\n    }\\n\\n    struct LPCStorage {\\n        mapping(address => Pool) pools;\\n        address[] allPools;\\n    }\\n\\n    struct FacetStorage {\\n        address ethAddress;\\n        address lpcAddress;\\n        address dataProviderAddress;\\n        address priceFeedAddress;\\n        address feeProviderAddress;\\n        address diamondAddress;\\n    }\\n\\n    struct InterestRate {\\n        InterestRateMode rateMode;\\n        uint256 targetUtilisationRate;\\n        uint256 interestRateSlopeBelow; // constant representing the scaling of the interest rate vs the utilization.\\n        uint256 interestRateSlopeAbove;\\n        uint256 baseVariableBorrowRate; // constant for totalBorrows = 0. Expressed in ray\\n        uint256 variableBorrowRate;\\n        uint256 overallBorrowRate; // (VariableBorrowRate * TotalVariableBorrows) / totalBorrows\\n        uint256 currentLiquidityRate; // overallBorrowRate * utilizationRate\\n    }\\n\\n    struct UserInterestRate {\\n        InterestRateMode rateMode;\\n        uint256 variableBorrowRate;\\n        uint256 stableBorrowRate;\\n        uint256 cumulatedVariableBorrowIndex;\\n    }\\n\\n    struct getPoolDisplayDataLocalVars {\\n        string asset;\\n        uint256 loanToValue;\\n        uint256 liquidationThreshold;\\n        uint256 liquidationBonus;\\n        uint256 depositedLiquidity;\\n        uint256 borrowedLiquidity;\\n        uint256 userBorrowedLiquidity;\\n        uint256 userRepayAmount;\\n        bool isBorrowingEnabled;\\n        bool isUsableAsCollateral;\\n    }\\n\\n    enum TokenVolatility {\\n        LOW,\\n        HIGH\\n    }\\n\\n    enum InterestRateMode {\\n        VARIABLE,\\n        STABLE,\\n        NONE\\n    }\\n\\n    function lpcStorage() internal pure returns (LPCStorage storage lpcs) {\\n        bytes32 position = LENDING_POOL_CORE_STORAGE_POSITION;\\n        assembly {\\n            lpcs.slot := position\\n        }\\n    }\\n\\n    function facetStorage() internal pure returns (FacetStorage storage fs) {\\n        bytes32 position = FACET_STORAGE_POSITION;\\n        assembly {\\n            fs.slot := position\\n        }\\n    }\\n\\n    function getDataProvider() internal view returns (DataProvider) {\\n        return DataProvider(facetStorage().dataProviderAddress);\\n    }\\n\\n    function getFeeProvider() internal view returns (FeeProvider) {\\n        return FeeProvider(facetStorage().feeProviderAddress);\\n    }\\n\\n    function getPriceFeed() internal view returns (PriceFeed) {\\n        return PriceFeed(facetStorage().priceFeedAddress);\\n    }\\n}\\n\",\"keccak256\":\"0xf37601451eba126ff5ad0aac5c53901e347802fe9182a75f3175e84f7291c6f0\",\"license\":\"No-License\"},\"contracts/libraries/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n **/\\nlibrary WadRayMath {\\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a*b, in wad\\n     **/\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n        assembly {\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(\\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a/b, in wad\\n     **/\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n        assembly {\\n            if or(\\n                iszero(b),\\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, WAD), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raymul b\\n     **/\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n        assembly {\\n            if iszero(\\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raydiv b\\n     **/\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n        assembly {\\n            if or(\\n                iszero(b),\\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, RAY), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @return b = a converted to wad, rounded half up to the nearest wad\\n     **/\\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := div(a, WAD_RAY_RATIO)\\n            let remainder := mod(a, WAD_RAY_RATIO)\\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\\n                b := add(b, 1)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @return b = a converted in ray\\n     **/\\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n        // to avoid overflow, b/WAD_RAY_RATIO == a\\n        assembly {\\n            b := mul(a, WAD_RAY_RATIO)\\n\\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rayMul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rayMul(z, x);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x74d16d29afcc5dcb605b47389af1535fedacd849714a76cdbac9700295594746\",\"license\":\"BUSL-1.1\"},\"contracts/mocks/EthMock.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"../libraries/LibFacet.sol\\\";\\n\\ncontract EthMock {\\n    function transferEthToUser(address _user, uint256 _amount) public payable {\\n        (bool success, ) = _user.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Error while sending ETH.\\\");\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xeaef772dbf936293c91daf1c7162209aaa53a0942156732f49ec9b137be8f64d\",\"license\":\"No-License\"},\"contracts/mocks/PriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract PriceFeed {\\n    address internal owner;\\n    mapping(address => AggregatorV3Interface) internal priceFeeds;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == owner,\\n            \\\"Only the owner of this smart contract can execute this action.\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    function addAssetOracle(address _asset, address _oracle)\\n        external\\n        onlyOwner\\n    {\\n        priceFeeds[_asset] = AggregatorV3Interface(_oracle);\\n    }\\n\\n    function getAssetPrice(address _asset) external view returns (uint256) {\\n        (, int256 price, , , ) = priceFeeds[_asset].latestRoundData();\\n        return uint256(price);\\n    }\\n}\\n\",\"keccak256\":\"0xebad21912db523c5e74ae2322211a33f5057f130fd579428e8317b50a5c69f84\",\"license\":\"No-License\"},\"contracts/mocks/UsdcMock.sol\":{\"content\":\"pragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract UsdcMock is ERC20 {\\n    constructor(address _to) ERC20(\\\"UsdcMock\\\", \\\"USDCM\\\") {\\n        _mint(_to, 10000 ether);\\n    }\\n\\n    function customApprove(\\n        address _owner,\\n        address _spender,\\n        uint256 _amount\\n    ) public {\\n        _approve(_owner, _spender, _amount);\\n    }\\n}\\n\",\"keccak256\":\"0xdf079725f583d609e2939715315faab77c1c7c13736943cbcab4f6e14364bcf6\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611c33806100206000396000f3fe6080604052600436106100555760003560e01c80631e9a69501461005a57806322867d781461007c5780633edd11281461008f578063824bbb04146100a25780638f7c2510146100c2578063b6e82e03146100d5575b600080fd5b34801561006657600080fd5b5061007a610075366004611806565b6100f5565b005b61007a61008a366004611806565b6103d1565b61007a61009d366004611841565b6108bf565b3480156100ae57600080fd5b5061007a6100bd366004611881565b610a2d565b61007a6100d03660046118b8565b610b88565b3480156100e157600080fd5b5061007a6100f0366004611903565b611162565b6040516361e9e5c760e11b815230908290829063c3d3cb8e9061011c90879060040161193c565b602060405180830381865afa158015610139573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061015d9190611950565b10156101b95760405162461bcd60e51b81526020600482015260326024820152600080516020611bde83398151915260448201527130b4b630b13632903a37903932b232b2b69760711b60648201526084015b60405180910390fd5b60405163a99901a360e01b81526001600160a01b0382169063a99901a3906101e79086903390600401611969565b602060405180830381865afa158015610204573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102289190611950565b8211156102965760405162461bcd60e51b815260206004820152603660248201527f557365722063616e6e6f742072656465656d206d6f7265207468616e207468656044820152751030b1b1bab6bab630ba32b21034b73a32b932b9ba1760511b60648201526084016101b0565b806001600160a01b031663afcdbea3843385856001600160a01b031663a99901a389336040518363ffffffff1660e01b81526004016102d6929190611969565b602060405180830381865afa1580156102f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103179190611950565b87146040518563ffffffff1660e01b81526004016103389493929190611983565b600060405180830381600087803b15801561035257600080fd5b505af1158015610366573d6000803e3d6000fd5b505060405163fa93b2a560e01b81526001600160a01b038416925063fa93b2a5915061039a908690339087906004016119ac565b600060405180830381600087803b1580156103b457600080fd5b505af11580156103c8573d6000803e3d6000fd5b50505050505050565b6000309050610420604051806101000160405280600081526020016000815260200160008152602001600015158152602001600081526020016000815260200160008152602001600081525090565b604051639fb8afcd60e01b81526001600160a01b03831690639fb8afcd9061044e9087903390600401611969565b606060405180830381865afa15801561046b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061048f91906119d0565b604080850191909152602084019190915290825251633faacc6b60e21b81526001600160a01b0383169063feab31ac906104cf9087903390600401611969565b602060405180830381865afa1580156104ec573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105109190611950565b60e08201526001600160a01b038416610527611738565b546001600160a01b0316146060820152602081015161059b5760405162461bcd60e51b815260206004820152602a60248201527f546865207573657220646f6573206e6f74206861766520616e7920626f72726f6044820152693b903832b73234b7339760b11b60648201526084016101b0565b8060e0015181602001516105af9190611a14565b608082018190528310156105c557608081018390525b806060015115806105da575080608001513410155b61063d5760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e74206d73672e76616c75652073656e6420666f722060448201526d3a3432903932b830bcb6b2b73a1760911b60648201526084016101b0565b8060e0015181608001511161073d576080810151604080830151905163da12d96f60e01b81526001600160a01b0385169263da12d96f9261068992899233926000928390600401611a2d565b600060405180830381600087803b1580156106a357600080fd5b505af11580156106b7573d6000803e3d6000fd5b50505050816001600160a01b0316639a88117482606001516106da5760006106e0565b82608001515b863385608001516040518563ffffffff1660e01b8152600401610705939291906119ac565b6000604051808303818588803b15801561071e57600080fd5b505af1158015610732573d6000803e3d6000fd5b505050505050505050565b8060e0015181608001516107519190611a63565b60a0820181905260e08201516040808401516020850151915163da12d96f60e01b81526001600160a01b0387169463da12d96f9461079a948b9433949091841490600401611a2d565b600060405180830381600087803b1580156107b457600080fd5b505af11580156107c8573d6000803e3d6000fd5b5050505060e08101511561085357816001600160a01b0316639a88117482606001516107f55760006107fb565b8260e001515b86338560e001516040518563ffffffff1660e01b8152600401610820939291906119ac565b6000604051808303818588803b15801561083957600080fd5b505af115801561084d573d6000803e3d6000fd5b50505050505b60a081015160405163dd2c99f760e01b81526001600160a01b0384169163dd2c99f7916108879188913391906004016119ac565b600060405180830381600087803b1580156108a157600080fd5b505af11580156108b5573d6000803e3d6000fd5b5050505050505050565b6108c7611738565b546001600160a01b03848116911614610950576040516370a0823160e01b815282906001600160a01b038516906370a082319061090890339060040161193c565b602060405180830381865afa158015610925573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109499190611950565b1015610956565b33318211155b6109a05760405162461bcd60e51b815260206004820152601b60248201527a24b739bab33334b1b4b2b73a103a37b5b2b7103130b630b731b29760291b60448201526064016101b0565b604051632f35bfe960e21b81523090819063bcd6ffa4906109cb908790339088908890600401611983565b600060405180830381600087803b1580156109e557600080fd5b505af11580156109f9573d6000803e3d6000fd5b505060405163dd2c99f760e01b81526001600160a01b038416925063dd2c99f79150610887908790339088906004016119ac565b6001600160a01b03821660009081527f66cfe6d1341bbca11619797516c7fbf0624d144c78b9a40a4a3b4fb518fc11b6602090815260408083203384526018810190925290912054610ad55760405162461bcd60e51b815260206004820152602b60248201527f5573657220646f6573206e6f74206861766520616e79206c697175696469747960448201526a103232b837b9b4ba32b21760a91b60648201526084016101b0565b33600090815260188201602052604090206009015460ff1615610b4e5760405162461bcd60e51b815260206004820152602b60248201527f55736572206465706f73697420697320616c726561647920757365642061732060448201526a31b7b63630ba32b930b61760a91b60648201526084016101b0565b604051630304fd0d60e31b81526001600160a01b038416600482015233602482015282151560448201523090631827e8689060640161039a565b6000309050610bec604051806101600160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b60405163f2ba567760e01b81526001600160a01b0383169063f2ba567790610c1a9088908890600401611969565b602060405180830381865afa158015610c37573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c5b9190611950565b808252610ccc5760405162461bcd60e51b815260206004820152603960248201527f5573657220686173206e6f742070726f766964656420636f6c6c61746572616c6044820152781034b7103a3432903232b9b4b932b21031bab93932b731bc9760391b60648201526084016101b0565b604051639fb8afcd60e01b81526001600160a01b03831690639fb8afcd90610cfa9089908890600401611969565b606060405180830381865afa158015610d17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3b91906119d0565b60408401526020830181905215159050610db35760405162461bcd60e51b815260206004820152603360248201527f5573657220686173206e6f7420676f7474656e2061206c6f616e20696e20746860448201527234b9903837b7b613b99031bab93932b731bc9760691b60648201526084016101b0565b60028160200151610dc49190611a76565b606082018190528311610dd75782610ddd565b80606001515b608082018190528151604051634b1f6d5360e01b81523092634b1f6d5392610e0d928b928b929091600401611a98565b6040805180830381865afa158015610e29573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e4d9190611ac1565b60c0830181905260a0830191909152608082015111610e70578060800151610e76565b8060c001515b6080820152604051633faacc6b60e21b81526001600160a01b0383169063feab31ac90610ea99089908890600401611969565b602060405180830381865afa158015610ec6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eea9190611950565b60e0820181905215610f805760e081015181513091634b1f6d539188918a91610f14908290611a63565b6040518563ffffffff1660e01b8152600401610f339493929190611a98565b6040805180830381865afa158015610f4f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f739190611ac1565b6101208301526101008201525b608081015161012082015160a08301516040808501519051634e912db560e01b81526001600160a01b038b811660048301528a8116602483015289811660448301526064820195909552608481019390935260a483019190915260c482015290831690634e912db59060e401600060405180830381600087803b15801561100657600080fd5b505af115801561101a573d6000803e3d6000fd5b50505060a082015160405163fa93b2a560e01b81526001600160a01b038516925063fa93b2a59161105191899133916004016119ac565b600060405180830381600087803b15801561106b57600080fd5b505af115801561107f573d6000803e3d6000fd5b505050608082015160405163dd2c99f760e01b81526001600160a01b038516925063dd2c99f7916110b6918a9133916004016119ac565b600060405180830381600087803b1580156110d057600080fd5b505af11580156110e4573d6000803e3d6000fd5b5050505060e08101511561115a576101208101516040516326a2045d60e21b81526001600160a01b03841691639a88117491611127918a913391906004016119ac565b600060405180830381600087803b15801561114157600080fd5b505af1158015611155573d6000803e3d6000fd5b505050505b505050505050565b61116a61175c565b60405163a5df1b2960e01b81523090819063a5df1b299061118f90889060040161193c565b602060405180830381865afa1580156111ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d09190611ae5565b6112275760405162461bcd60e51b815260206004820152602260248201527f506f6f6c206973206e6f7420656e61626c656420666f7220626f72726f77696e604482015261339760f11b60648201526084016101b0565b600083600281111561123b5761123b611b09565b14806112585750600183600281111561125657611256611b09565b145b6112b05760405162461bcd60e51b815260206004820152602360248201527f496e76616c696420696e7465726573742072617465206d6f64652073656c65636044820152621d195960ea1b60648201526084016101b0565b6040516361e9e5c760e11b815284906001600160a01b0383169063c3d3cb8e906112de90899060040161193c565b602060405180830381865afa1580156112fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061131f9190611950565b10156113785760405162461bcd60e51b81526020600482015260346024820152600080516020611bde83398151915260448201527330b4b630b136329034b7103a3432903837b7b61760611b60648201526084016101b0565b6040516370fd015d60e11b8152309063e1fa02ba9061139b90339060040161193c565b61010060405180830381865afa1580156113b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113dd9190611b1f565b15156101e08a0152506040880152602087015261010086015260e085015260c08401819052151590506114515760405162461bcd60e51b815260206004820152601c60248201527b2a34329031b7b63630ba32b930b6103130b630b731b29034b990181760211b60448201526064016101b0565b816101e00151156114b45760405162461bcd60e51b815260206004820152602760248201527f54686520626f72726f7765722063616e20616c7265616479206265206c69717560448201526634b230ba32b21760c91b60648201526084016101b0565b60405163249bbe9160e01b815260048101859052309063249bbe9190602401602060405180830381865afa1580156114f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115149190611950565b606083018190526115725760405162461bcd60e51b815260206004820152602260248201527f54686520616d6f756e7420746f20626f72726f7720697320746f6f20736d616c604482015261361760f11b60648201526084016101b0565b606082015160e083015161010084015160208501516040516312737c3360e01b81526001600160a01b038a1660048201526024810189905260448101949094526064840192909252608483015260a482015230906312737c339060c401602060405180830381865afa1580156115ec573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116109190611950565b60a0830181905260c083015110156116815760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e7420636f6c6c61746572616c20746f20636f76657260448201526d1030903732bb903137b93937bb9760911b60648201526084016101b0565b60608201516101c0830151604051630deb1bf960e21b81526001600160a01b038416926337ac6fe4926116bc928a9233928b92600401611b89565b600060405180830381600087803b1580156116d657600080fd5b505af11580156116ea573d6000803e3d6000fd5b505060405163fa93b2a560e01b81526001600160a01b038416925063fa93b2a5915061171e908890339089906004016119ac565b600060405180830381600087803b15801561071e57600080fd5b7fff5923912191a1cc1ce52c1e63600d3ff20a63ae0f4211e3199b7ba72a991b5a90565b6040518061020001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600060028111156117dd576117dd611b09565b8152600060209091015290565b80356001600160a01b038116811461180157600080fd5b919050565b6000806040838503121561181957600080fd5b611822836117ea565b946020939093013593505050565b801515811461183e57600080fd5b50565b60008060006060848603121561185657600080fd5b61185f846117ea565b925060208401359150604084013561187681611830565b809150509250925092565b6000806040838503121561189457600080fd5b61189d836117ea565b915060208301356118ad81611830565b809150509250929050565b600080600080608085870312156118ce57600080fd5b6118d7856117ea565b93506118e5602086016117ea565b92506118f3604086016117ea565b9396929550929360600135925050565b60008060006060848603121561191857600080fd5b611921846117ea565b92506020840135915060408401356003811061187657600080fd5b6001600160a01b0391909116815260200190565b60006020828403121561196257600080fd5b5051919050565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b0394851681529290931660208301526040820152901515606082015260800190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6000806000606084860312156119e557600080fd5b8351925060208401519150604084015190509250925092565b634e487b7160e01b600052601160045260246000fd5b80820180821115611a2757611a276119fe565b92915050565b6001600160a01b03968716815294909516602085015260408401929092526060830152608082015290151560a082015260c00190565b81810381811115611a2757611a276119fe565b600082611a9357634e487b7160e01b600052601260045260246000fd5b500490565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b60008060408385031215611ad457600080fd5b505080516020909101519092909150565b600060208284031215611af757600080fd5b8151611b0281611830565b9392505050565b634e487b7160e01b600052602160045260246000fd5b600080600080600080600080610100898b031215611b3c57600080fd5b885197506020890151965060408901519550606089015194506080890151935060a0890151925060c0890151915060e0890151611b7881611830565b809150509295985092959890939650565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0810160038310611bcd57634e487b7160e01b600052602160045260246000fd5b826080830152969550505050505056fe5468657265206973206e6f7420656e6f756768206c6971756964697479206176a2646970667358221220ceae94de7595fc50b6d0b64690ce3792850d31cdb8ee2f4e22a23102bbe19e6e64736f6c63430008110033",
  "deployedBytecode": "0x6080604052600436106100555760003560e01c80631e9a69501461005a57806322867d781461007c5780633edd11281461008f578063824bbb04146100a25780638f7c2510146100c2578063b6e82e03146100d5575b600080fd5b34801561006657600080fd5b5061007a610075366004611806565b6100f5565b005b61007a61008a366004611806565b6103d1565b61007a61009d366004611841565b6108bf565b3480156100ae57600080fd5b5061007a6100bd366004611881565b610a2d565b61007a6100d03660046118b8565b610b88565b3480156100e157600080fd5b5061007a6100f0366004611903565b611162565b6040516361e9e5c760e11b815230908290829063c3d3cb8e9061011c90879060040161193c565b602060405180830381865afa158015610139573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061015d9190611950565b10156101b95760405162461bcd60e51b81526020600482015260326024820152600080516020611bde83398151915260448201527130b4b630b13632903a37903932b232b2b69760711b60648201526084015b60405180910390fd5b60405163a99901a360e01b81526001600160a01b0382169063a99901a3906101e79086903390600401611969565b602060405180830381865afa158015610204573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102289190611950565b8211156102965760405162461bcd60e51b815260206004820152603660248201527f557365722063616e6e6f742072656465656d206d6f7265207468616e207468656044820152751030b1b1bab6bab630ba32b21034b73a32b932b9ba1760511b60648201526084016101b0565b806001600160a01b031663afcdbea3843385856001600160a01b031663a99901a389336040518363ffffffff1660e01b81526004016102d6929190611969565b602060405180830381865afa1580156102f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103179190611950565b87146040518563ffffffff1660e01b81526004016103389493929190611983565b600060405180830381600087803b15801561035257600080fd5b505af1158015610366573d6000803e3d6000fd5b505060405163fa93b2a560e01b81526001600160a01b038416925063fa93b2a5915061039a908690339087906004016119ac565b600060405180830381600087803b1580156103b457600080fd5b505af11580156103c8573d6000803e3d6000fd5b50505050505050565b6000309050610420604051806101000160405280600081526020016000815260200160008152602001600015158152602001600081526020016000815260200160008152602001600081525090565b604051639fb8afcd60e01b81526001600160a01b03831690639fb8afcd9061044e9087903390600401611969565b606060405180830381865afa15801561046b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061048f91906119d0565b604080850191909152602084019190915290825251633faacc6b60e21b81526001600160a01b0383169063feab31ac906104cf9087903390600401611969565b602060405180830381865afa1580156104ec573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105109190611950565b60e08201526001600160a01b038416610527611738565b546001600160a01b0316146060820152602081015161059b5760405162461bcd60e51b815260206004820152602a60248201527f546865207573657220646f6573206e6f74206861766520616e7920626f72726f6044820152693b903832b73234b7339760b11b60648201526084016101b0565b8060e0015181602001516105af9190611a14565b608082018190528310156105c557608081018390525b806060015115806105da575080608001513410155b61063d5760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e74206d73672e76616c75652073656e6420666f722060448201526d3a3432903932b830bcb6b2b73a1760911b60648201526084016101b0565b8060e0015181608001511161073d576080810151604080830151905163da12d96f60e01b81526001600160a01b0385169263da12d96f9261068992899233926000928390600401611a2d565b600060405180830381600087803b1580156106a357600080fd5b505af11580156106b7573d6000803e3d6000fd5b50505050816001600160a01b0316639a88117482606001516106da5760006106e0565b82608001515b863385608001516040518563ffffffff1660e01b8152600401610705939291906119ac565b6000604051808303818588803b15801561071e57600080fd5b505af1158015610732573d6000803e3d6000fd5b505050505050505050565b8060e0015181608001516107519190611a63565b60a0820181905260e08201516040808401516020850151915163da12d96f60e01b81526001600160a01b0387169463da12d96f9461079a948b9433949091841490600401611a2d565b600060405180830381600087803b1580156107b457600080fd5b505af11580156107c8573d6000803e3d6000fd5b5050505060e08101511561085357816001600160a01b0316639a88117482606001516107f55760006107fb565b8260e001515b86338560e001516040518563ffffffff1660e01b8152600401610820939291906119ac565b6000604051808303818588803b15801561083957600080fd5b505af115801561084d573d6000803e3d6000fd5b50505050505b60a081015160405163dd2c99f760e01b81526001600160a01b0384169163dd2c99f7916108879188913391906004016119ac565b600060405180830381600087803b1580156108a157600080fd5b505af11580156108b5573d6000803e3d6000fd5b5050505050505050565b6108c7611738565b546001600160a01b03848116911614610950576040516370a0823160e01b815282906001600160a01b038516906370a082319061090890339060040161193c565b602060405180830381865afa158015610925573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109499190611950565b1015610956565b33318211155b6109a05760405162461bcd60e51b815260206004820152601b60248201527a24b739bab33334b1b4b2b73a103a37b5b2b7103130b630b731b29760291b60448201526064016101b0565b604051632f35bfe960e21b81523090819063bcd6ffa4906109cb908790339088908890600401611983565b600060405180830381600087803b1580156109e557600080fd5b505af11580156109f9573d6000803e3d6000fd5b505060405163dd2c99f760e01b81526001600160a01b038416925063dd2c99f79150610887908790339088906004016119ac565b6001600160a01b03821660009081527f66cfe6d1341bbca11619797516c7fbf0624d144c78b9a40a4a3b4fb518fc11b6602090815260408083203384526018810190925290912054610ad55760405162461bcd60e51b815260206004820152602b60248201527f5573657220646f6573206e6f74206861766520616e79206c697175696469747960448201526a103232b837b9b4ba32b21760a91b60648201526084016101b0565b33600090815260188201602052604090206009015460ff1615610b4e5760405162461bcd60e51b815260206004820152602b60248201527f55736572206465706f73697420697320616c726561647920757365642061732060448201526a31b7b63630ba32b930b61760a91b60648201526084016101b0565b604051630304fd0d60e31b81526001600160a01b038416600482015233602482015282151560448201523090631827e8689060640161039a565b6000309050610bec604051806101600160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581525090565b60405163f2ba567760e01b81526001600160a01b0383169063f2ba567790610c1a9088908890600401611969565b602060405180830381865afa158015610c37573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c5b9190611950565b808252610ccc5760405162461bcd60e51b815260206004820152603960248201527f5573657220686173206e6f742070726f766964656420636f6c6c61746572616c6044820152781034b7103a3432903232b9b4b932b21031bab93932b731bc9760391b60648201526084016101b0565b604051639fb8afcd60e01b81526001600160a01b03831690639fb8afcd90610cfa9089908890600401611969565b606060405180830381865afa158015610d17573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d3b91906119d0565b60408401526020830181905215159050610db35760405162461bcd60e51b815260206004820152603360248201527f5573657220686173206e6f7420676f7474656e2061206c6f616e20696e20746860448201527234b9903837b7b613b99031bab93932b731bc9760691b60648201526084016101b0565b60028160200151610dc49190611a76565b606082018190528311610dd75782610ddd565b80606001515b608082018190528151604051634b1f6d5360e01b81523092634b1f6d5392610e0d928b928b929091600401611a98565b6040805180830381865afa158015610e29573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e4d9190611ac1565b60c0830181905260a0830191909152608082015111610e70578060800151610e76565b8060c001515b6080820152604051633faacc6b60e21b81526001600160a01b0383169063feab31ac90610ea99089908890600401611969565b602060405180830381865afa158015610ec6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eea9190611950565b60e0820181905215610f805760e081015181513091634b1f6d539188918a91610f14908290611a63565b6040518563ffffffff1660e01b8152600401610f339493929190611a98565b6040805180830381865afa158015610f4f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f739190611ac1565b6101208301526101008201525b608081015161012082015160a08301516040808501519051634e912db560e01b81526001600160a01b038b811660048301528a8116602483015289811660448301526064820195909552608481019390935260a483019190915260c482015290831690634e912db59060e401600060405180830381600087803b15801561100657600080fd5b505af115801561101a573d6000803e3d6000fd5b50505060a082015160405163fa93b2a560e01b81526001600160a01b038516925063fa93b2a59161105191899133916004016119ac565b600060405180830381600087803b15801561106b57600080fd5b505af115801561107f573d6000803e3d6000fd5b505050608082015160405163dd2c99f760e01b81526001600160a01b038516925063dd2c99f7916110b6918a9133916004016119ac565b600060405180830381600087803b1580156110d057600080fd5b505af11580156110e4573d6000803e3d6000fd5b5050505060e08101511561115a576101208101516040516326a2045d60e21b81526001600160a01b03841691639a88117491611127918a913391906004016119ac565b600060405180830381600087803b15801561114157600080fd5b505af1158015611155573d6000803e3d6000fd5b505050505b505050505050565b61116a61175c565b60405163a5df1b2960e01b81523090819063a5df1b299061118f90889060040161193c565b602060405180830381865afa1580156111ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d09190611ae5565b6112275760405162461bcd60e51b815260206004820152602260248201527f506f6f6c206973206e6f7420656e61626c656420666f7220626f72726f77696e604482015261339760f11b60648201526084016101b0565b600083600281111561123b5761123b611b09565b14806112585750600183600281111561125657611256611b09565b145b6112b05760405162461bcd60e51b815260206004820152602360248201527f496e76616c696420696e7465726573742072617465206d6f64652073656c65636044820152621d195960ea1b60648201526084016101b0565b6040516361e9e5c760e11b815284906001600160a01b0383169063c3d3cb8e906112de90899060040161193c565b602060405180830381865afa1580156112fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061131f9190611950565b10156113785760405162461bcd60e51b81526020600482015260346024820152600080516020611bde83398151915260448201527330b4b630b136329034b7103a3432903837b7b61760611b60648201526084016101b0565b6040516370fd015d60e11b8152309063e1fa02ba9061139b90339060040161193c565b61010060405180830381865afa1580156113b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113dd9190611b1f565b15156101e08a0152506040880152602087015261010086015260e085015260c08401819052151590506114515760405162461bcd60e51b815260206004820152601c60248201527b2a34329031b7b63630ba32b930b6103130b630b731b29034b990181760211b60448201526064016101b0565b816101e00151156114b45760405162461bcd60e51b815260206004820152602760248201527f54686520626f72726f7765722063616e20616c7265616479206265206c69717560448201526634b230ba32b21760c91b60648201526084016101b0565b60405163249bbe9160e01b815260048101859052309063249bbe9190602401602060405180830381865afa1580156114f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115149190611950565b606083018190526115725760405162461bcd60e51b815260206004820152602260248201527f54686520616d6f756e7420746f20626f72726f7720697320746f6f20736d616c604482015261361760f11b60648201526084016101b0565b606082015160e083015161010084015160208501516040516312737c3360e01b81526001600160a01b038a1660048201526024810189905260448101949094526064840192909252608483015260a482015230906312737c339060c401602060405180830381865afa1580156115ec573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116109190611950565b60a0830181905260c083015110156116815760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e7420636f6c6c61746572616c20746f20636f76657260448201526d1030903732bb903137b93937bb9760911b60648201526084016101b0565b60608201516101c0830151604051630deb1bf960e21b81526001600160a01b038416926337ac6fe4926116bc928a9233928b92600401611b89565b600060405180830381600087803b1580156116d657600080fd5b505af11580156116ea573d6000803e3d6000fd5b505060405163fa93b2a560e01b81526001600160a01b038416925063fa93b2a5915061171e908890339089906004016119ac565b600060405180830381600087803b15801561071e57600080fd5b7fff5923912191a1cc1ce52c1e63600d3ff20a63ae0f4211e3199b7ba72a991b5a90565b6040518061020001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600060028111156117dd576117dd611b09565b8152600060209091015290565b80356001600160a01b038116811461180157600080fd5b919050565b6000806040838503121561181957600080fd5b611822836117ea565b946020939093013593505050565b801515811461183e57600080fd5b50565b60008060006060848603121561185657600080fd5b61185f846117ea565b925060208401359150604084013561187681611830565b809150509250925092565b6000806040838503121561189457600080fd5b61189d836117ea565b915060208301356118ad81611830565b809150509250929050565b600080600080608085870312156118ce57600080fd5b6118d7856117ea565b93506118e5602086016117ea565b92506118f3604086016117ea565b9396929550929360600135925050565b60008060006060848603121561191857600080fd5b611921846117ea565b92506020840135915060408401356003811061187657600080fd5b6001600160a01b0391909116815260200190565b60006020828403121561196257600080fd5b5051919050565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b0394851681529290931660208301526040820152901515606082015260800190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6000806000606084860312156119e557600080fd5b8351925060208401519150604084015190509250925092565b634e487b7160e01b600052601160045260246000fd5b80820180821115611a2757611a276119fe565b92915050565b6001600160a01b03968716815294909516602085015260408401929092526060830152608082015290151560a082015260c00190565b81810381811115611a2757611a276119fe565b600082611a9357634e487b7160e01b600052601260045260246000fd5b500490565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b60008060408385031215611ad457600080fd5b505080516020909101519092909150565b600060208284031215611af757600080fd5b8151611b0281611830565b9392505050565b634e487b7160e01b600052602160045260246000fd5b600080600080600080600080610100898b031215611b3c57600080fd5b885197506020890151965060408901519550606089015194506080890151935060a0890151925060c0890151915060e0890151611b7881611830565b809150509295985092959890939650565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0810160038310611bcd57634e487b7160e01b600052602160045260246000fd5b826080830152969550505050505056fe5468657265206973206e6f7420656e6f756768206c6971756964697479206176a2646970667358221220ceae94de7595fc50b6d0b64690ce3792850d31cdb8ee2f4e22a23102bbe19e6e64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}