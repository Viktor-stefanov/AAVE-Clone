{
  "address": "0x1f10F3Ba7ACB61b2F50B9d6DdCf91a6f787C0E82",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "enum LibFacet.InterestRateMode",
          "name": "_rateMode",
          "type": "uint8"
        }
      ],
      "name": "borrow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "redeem",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "repay",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0xfd31d8fa3eb52bbc43d50026ddbdb61c865485261feb1415adedfae1bbd43b33",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x1f10F3Ba7ACB61b2F50B9d6DdCf91a6f787C0E82",
    "transactionIndex": 0,
    "gasUsed": "1048230",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x98df4fcf4f6fd25bd8c8da4a06fa53cb9b71667250a6f64a595519972d709ac3",
    "transactionHash": "0xfd31d8fa3eb52bbc43d50026ddbdb61c865485261feb1415adedfae1bbd43b33",
    "logs": [],
    "blockNumber": 124,
    "cumulativeGasUsed": "1048230",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "441b63157a0e59203de0aa8c377051b6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum LibFacet.InterestRateMode\",\"name\":\"_rateMode\",\"type\":\"uint8\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/LendingPool.sol\":\"LendingPool\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x4ffc0547c02ad22925310c585c0f166f8759e2648a09e9b489100c42f15dd98d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/DataProvider.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"./libraries/LibFacet.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract DataProvider {\\n    using WadRayMath for uint256;\\n\\n    struct GetUserGlobalDataVars {\\n        uint256 compoundedLiquidityBalance;\\n        uint256 compoundedBorrowBalance;\\n        uint256 originationFee;\\n        uint256 reserveDecimals;\\n        uint256 baseLTV;\\n        uint256 liquidationThreshold;\\n        uint256 tokenUnit;\\n        uint256 poolUnitPrice;\\n        uint256 liquidityBalanceETH;\\n        bool userUsesReserveAsCollateral;\\n        bool usageAsCollateralEnabled;\\n    }\\n\\n    /// @dev get user data accross all pools\\n    function getUserGlobalData(address _user)\\n        public\\n        view\\n        returns (\\n            uint256 totalLiquidityBalanceETH,\\n            uint256 totalCollateralBalanceETH,\\n            uint256 totalBorrowBalanceETH,\\n            uint256 totalFeesETH,\\n            uint256 currentLTV,\\n            uint256 currentLiquidationThreshold,\\n            uint256 healthFactor,\\n            bool healthFactorBelowThreshold\\n        )\\n    {\\n        GetUserGlobalDataVars memory vars;\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        address[] memory pools = LibFacet.lpcStorage().allPools;\\n        for (uint256 poolIdx = 0; poolIdx < pools.length; poolIdx++) {\\n            (\\n                vars.compoundedLiquidityBalance,\\n                vars.compoundedBorrowBalance,\\n                vars.originationFee,\\n                vars.userUsesReserveAsCollateral\\n            ) = core.getUserPoolData(pools[poolIdx], _user);\\n\\n            if (\\n                vars.compoundedBorrowBalance == 0 &&\\n                vars.compoundedLiquidityBalance == 0\\n            ) continue;\\n\\n            (\\n                vars.reserveDecimals,\\n                vars.baseLTV,\\n                vars.liquidationThreshold,\\n                vars.usageAsCollateralEnabled\\n            ) = core.getPoolConfiguration(pools[poolIdx]);\\n\\n            vars.tokenUnit = 10**vars.reserveDecimals;\\n            vars.poolUnitPrice = LibFacet.getPriceFeed().getAssetPrice(\\n                pools[poolIdx]\\n            );\\n\\n            if (vars.compoundedLiquidityBalance > 0) {\\n                vars.liquidityBalanceETH =\\n                    (vars.poolUnitPrice * vars.compoundedLiquidityBalance) /\\n                    vars.tokenUnit;\\n                totalLiquidityBalanceETH += vars.liquidityBalanceETH;\\n\\n                if (\\n                    vars.usageAsCollateralEnabled &&\\n                    vars.userUsesReserveAsCollateral\\n                ) {\\n                    totalCollateralBalanceETH += vars.liquidityBalanceETH;\\n                    currentLTV += vars.liquidityBalanceETH * vars.baseLTV;\\n                    currentLiquidationThreshold +=\\n                        vars.liquidityBalanceETH *\\n                        vars.liquidationThreshold;\\n                }\\n            }\\n\\n            if (vars.compoundedBorrowBalance > 0) {\\n                totalBorrowBalanceETH +=\\n                    (vars.poolUnitPrice * vars.compoundedBorrowBalance) /\\n                    vars.tokenUnit;\\n                totalFeesETH +=\\n                    (vars.originationFee * vars.poolUnitPrice) /\\n                    vars.tokenUnit;\\n            }\\n        }\\n\\n        currentLTV = totalCollateralBalanceETH > 0\\n            ? currentLTV / totalCollateralBalanceETH\\n            : 0;\\n        currentLiquidationThreshold = totalCollateralBalanceETH > 0\\n            ? currentLiquidationThreshold / totalCollateralBalanceETH\\n            : 0;\\n        healthFactor = calculateHealthFactorFromBalances(\\n            totalCollateralBalanceETH,\\n            totalBorrowBalanceETH,\\n            totalFeesETH,\\n            currentLiquidationThreshold\\n        );\\n        healthFactorBelowThreshold = healthFactor < 1e18;\\n    }\\n\\n    function calculateHealthFactorFromBalances(\\n        uint256 _totalCollateralBalanceETH,\\n        uint256 _totalBorrowBalanceETH,\\n        uint256 _totalFeesETH,\\n        uint256 _currentLiquidationThreshold\\n    ) internal pure returns (uint256) {\\n        if (_totalBorrowBalanceETH == 0) return type(uint256).max;\\n\\n        return\\n            ((_totalCollateralBalanceETH * _currentLiquidationThreshold) / 100)\\n                .wadDiv(_totalBorrowBalanceETH + _totalFeesETH);\\n    }\\n\\n    function calculateCollateralNeededInETH(\\n        address _pool,\\n        uint256 _amount,\\n        uint256 _fee,\\n        uint256 _userCurrentBorrowBalanceETH,\\n        uint256 _userCurrentFeesETH,\\n        uint256 _userCurrentLTV\\n    ) external view returns (uint256 collateralNeededInETH) {\\n        PriceFeed pf = LibFacet.getPriceFeed();\\n\\n        uint256 poolDecimals = LendingPoolCore(address(this)).getPoolDecimals(\\n            _pool\\n        );\\n        uint256 requestedBorrowAmountETH = (pf.getAssetPrice(_pool) *\\n            (_amount + _fee)) / 10**poolDecimals;\\n        collateralNeededInETH =\\n            ((_userCurrentBorrowBalanceETH +\\n                _userCurrentFeesETH +\\n                requestedBorrowAmountETH) * 100) /\\n            _userCurrentLTV;\\n    }\\n}\\n\",\"keccak256\":\"0x8343024d8658ae9805c1fad832fe908ee2578608f16b7ebda820266c852b4f2b\",\"license\":\"No-License\"},\"contracts/FeeProvider.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"./libraries/WadRayMath.sol\\\";\\n\\ncontract FeeProvider {\\n    using WadRayMath for uint256;\\n\\n    uint256 internal constant originationFeePercentage = 0.0025 * 1e18;\\n\\n    function calculateLoanOriginationFee(uint256 _amount)\\n        external\\n        pure\\n        returns (uint256)\\n    {\\n        return _amount.wadMul(originationFeePercentage);\\n    }\\n}\\n\",\"keccak256\":\"0x67dbf3f38bbf2b181301f9be4d298fa2af8bf6d4f9e85101a9c7eca421b89310\",\"license\":\"No-License\"},\"contracts/LendingPool.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./libraries/LibFacet.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract LendingPool {\\n    function deposit(\\n        address _pool,\\n        address _user,\\n        uint256 _amount\\n    ) external payable {\\n        require(\\n            _pool == LibFacet.facetStorage().ethAddress\\n                ? _user.balance >= _amount\\n                : ERC20(_pool).balanceOf(_user) >= _amount,\\n            \\\"Insufficient token balance.\\\"\\n        );\\n\\n        LendingPoolCore(address(this)).updateStateOnDeposit(\\n            _pool,\\n            msg.sender,\\n            _amount\\n        );\\n    }\\n\\n    function redeem(\\n        address _pool,\\n        address _user,\\n        uint256 _amount\\n    ) external {\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        require(\\n            pool.totalLiquidity >= _amount,\\n            \\\"There is not enough liquidity available to redeem.\\\"\\n        );\\n        core.updateStateOnRedeem(\\n            _pool,\\n            msg.sender,\\n            _amount,\\n            _amount == pool.users[_user].liquidityProvided\\n        );\\n        core.transferToUser(_pool, _user, _amount);\\n    }\\n\\n    struct BorrowLocalVars {\\n        uint256 principalBorrowBalance;\\n        uint256 currentLTV;\\n        uint256 currentLiquidationThreshold;\\n        uint256 borrowFee;\\n        uint256 requestedBorrowAmountETH;\\n        uint256 amountOfCollateralNeededETH;\\n        uint256 userCollateralBalanceETH;\\n        uint256 userBorrowBalanceETH;\\n        uint256 userTotalFeesETH;\\n        uint256 borrowBalanceIncrease;\\n        uint256 currentReserveStableRate;\\n        uint256 availableLiquidity;\\n        uint256 reserveDecimals;\\n        uint256 finalUserBorrowRate;\\n        LibFacet.InterestRateMode rateMode;\\n        bool healthFactorBelowThreshold;\\n    }\\n\\n    function borrow(\\n        address _pool,\\n        uint256 _amount,\\n        LibFacet.InterestRateMode _rateMode\\n    ) external {\\n        BorrowLocalVars memory vars;\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        require(\\n            core.isPoolBorrowingEnabled(_pool),\\n            \\\"Pool is not enabled for borrowing.\\\"\\n        );\\n        require(\\n            _rateMode == LibFacet.InterestRateMode.VARIABLE ||\\n                _rateMode == LibFacet.InterestRateMode.STABLE,\\n            \\\"Invalid interest rate mode selected\\\"\\n        );\\n        require(\\n            core.getPoolAvailableLiquidity(_pool) >= _amount,\\n            \\\"There is not enough liquidity available in the pool.\\\"\\n        );\\n\\n        (\\n            ,\\n            vars.userCollateralBalanceETH,\\n            vars.userBorrowBalanceETH,\\n            vars.userTotalFeesETH,\\n            vars.currentLTV,\\n            vars.currentLiquidationThreshold,\\n            ,\\n            vars.healthFactorBelowThreshold\\n        ) = DataProvider(address(this)).getUserGlobalData(msg.sender);\\n\\n        require(\\n            vars.userCollateralBalanceETH > 0,\\n            \\\"The collateral balance is 0.\\\"\\n        );\\n        require(\\n            !vars.healthFactorBelowThreshold,\\n            \\\"The borrower can already be liquidated.\\\"\\n        );\\n\\n        vars.borrowFee = FeeProvider(address(this)).calculateLoanOriginationFee(\\n            _amount\\n        );\\n\\n        require(vars.borrowFee > 0, \\\"The amount to borrow is too small.\\\");\\n\\n        vars.amountOfCollateralNeededETH = DataProvider(address(this))\\n            .calculateCollateralNeededInETH(\\n                _pool,\\n                _amount,\\n                vars.borrowFee,\\n                vars.userBorrowBalanceETH,\\n                vars.userTotalFeesETH,\\n                vars.currentLTV\\n            );\\n\\n        require(\\n            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\\n            \\\"Insufficient collateral to cover a new borrow.\\\"\\n        );\\n\\n        /// TODO: add stable rate checks\\n        (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core\\n            .updateStateOnBorrow(\\n                _pool,\\n                msg.sender,\\n                _amount,\\n                vars.borrowFee,\\n                vars.rateMode\\n            );\\n\\n        core.transferToUser(_pool, msg.sender, _amount);\\n    }\\n\\n    struct RepayLocalVars {\\n        uint256 principalBorrowBalance;\\n        uint256 compoundedBorrowBalance;\\n        uint256 borrowBalanceIncrease;\\n        bool isETH;\\n        uint256 paybackAmount;\\n        uint256 paybackAmountMinusFees;\\n        uint256 currentStableRate;\\n        uint256 originationFee;\\n    }\\n\\n    function repay(address _pool, uint256 _amount) external payable {\\n        LendingPoolCore core = LendingPoolCore(address(this));\\n        RepayLocalVars memory vars;\\n\\n        (\\n            vars.principalBorrowBalance,\\n            vars.compoundedBorrowBalance,\\n            vars.borrowBalanceIncrease\\n        ) = core.getUserBorrowBalances(_pool, msg.sender);\\n\\n        vars.originationFee = core.getUserOriginationFee(_pool, msg.sender);\\n        vars.isETH = LibFacet.facetStorage().ethAddress == _pool;\\n\\n        require(\\n            vars.compoundedBorrowBalance > 0,\\n            \\\"The user does nto have any borrow pending.\\\"\\n        );\\n\\n        vars.paybackAmount = vars.compoundedBorrowBalance + vars.originationFee;\\n\\n        require(\\n            !vars.isETH || msg.value >= vars.paybackAmount,\\n            \\\"Insufficient msg.value send for the repayment.\\\"\\n        );\\n\\n        // if the payback amount is smaller than the origination fee, just transfer the amount to the fee destination address\\n        if (vars.paybackAmount <= vars.originationFee) {\\n            core.updateStateOnRepay(\\n                _pool,\\n                msg.sender,\\n                0,\\n                vars.paybackAmount,\\n                vars.borrowBalanceIncrease,\\n                false\\n            );\\n            core.transferToFeeCollector{\\n                value: vars.isETH ? vars.paybackAmount : 0\\n            }(_pool, msg.sender, vars.paybackAmount);\\n            return;\\n        }\\n\\n        vars.paybackAmountMinusFees = vars.paybackAmount - vars.originationFee;\\n        core.updateStateOnRepay(\\n            _pool,\\n            msg.sender,\\n            vars.paybackAmountMinusFees,\\n            vars.originationFee,\\n            vars.borrowBalanceIncrease,\\n            vars.compoundedBorrowBalance == vars.paybackAmountMinusFees\\n        );\\n\\n        if (vars.originationFee > 0) {\\n            core.transferToFeeCollector{\\n                value: vars.isETH ? vars.originationFee : 0\\n            }(_pool, msg.sender, vars.originationFee);\\n        }\\n\\n        core.transferToPool{\\n            value: vars.isETH ? msg.value - vars.originationFee : 0\\n        }(_pool, msg.sender, vars.paybackAmountMinusFees);\\n    }\\n\\n    //function setUserUsePoolAsCollateral(address _pool, bool _useAsCollateral)\\n    //    external\\n    //{\\n    //    LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n    //    require(\\n    //        pool.user[msg.sender].liquidityProvided > 0,\\n    //        \\\"User does not have any liquidity deposited.\\\"\\n    //    );\\n    //    require(\\n    //        !pool.user[msg.sender].useAsCollateral,\\n    //        \\\"User deposit is already used as collateral.\\\"\\n    //    );\\n    //    setUserUsePoolAsCollateralInternal(\\n    //        pool.user[msg.sender],\\n    //        _useAsCollateral\\n    //    );\\n    //}\\n}\\n\",\"keccak256\":\"0x2a0991ac87a778893ccd7231a16b8fab10253196c00bd9b1c31b0549885e5f54\",\"license\":\"No-License\"},\"contracts/LendingPoolCore.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"./libraries/LibFacet.sol\\\";\\nimport \\\"./libraries/WadRayMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract LendingPoolCore {\\n    using WadRayMath for uint256;\\n\\n    function getEthValue(address _token, uint256 _amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 loanToValue = LibFacet.lpcStorage().pools[_token].loanToValue;\\n        return ((_amount * loanToValue) / 100);\\n    }\\n\\n    function testPrint(LibFacet.Pool storage pool) internal view {\\n        console.log(pool.totalLiquidity);\\n        console.log(pool.cumulatedLiquidityIndex);\\n        console.log(pool.rates.variableBorrowRate);\\n    }\\n\\n    function updateStateOnDeposit(\\n        address _pool,\\n        address _user,\\n        uint256 _amount\\n    ) public {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        testPrint(pool);\\n        updateCumulativeIndexes(pool);\\n        updatePoolInterestRates(pool, _amount, 0);\\n        bool isFirstDeposit = pool.users[_user].liquidityProvided == 0;\\n        pool.totalLiquidity += _amount;\\n        pool.users[_user].liquidityProvided += _amount;\\n        if (isFirstDeposit)\\n            setUserUsePoolAsCollateralInternal(pool.users[_user], true);\\n    }\\n\\n    function updateStateOnRedeem(\\n        address _pool,\\n        address _user,\\n        uint256 _amount,\\n        bool _userRedeemedEverything\\n    ) public {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        updateCumulativeIndexes(pool);\\n        updatePoolInterestRates(pool, 0, _amount);\\n        /// TODO: subtract the original amount or the accumulated amount?\\n        pool.totalLiquidity -= _amount;\\n        pool.users[_user].liquidityProvided -= _amount;\\n        if (_userRedeemedEverything)\\n            setUserUsePoolAsCollateralInternal(pool.users[_user], false);\\n    }\\n\\n    function updateStateOnBorrow(\\n        address _pool,\\n        address _user,\\n        uint256 _amount,\\n        uint256 _borrowFee,\\n        LibFacet.InterestRateMode _rateMode\\n    ) public returns (uint256, uint256) {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        testPrint(pool);\\n        (\\n            uint256 principalBorrowBalance,\\n            ,\\n            uint256 balanceIncrease\\n        ) = getUserBorrowBalances(_pool, _user);\\n\\n        updatePoolStateOnBorrow(\\n            pool,\\n            _user,\\n            principalBorrowBalance,\\n            balanceIncrease,\\n            _amount,\\n            _rateMode\\n        );\\n\\n        updateUserStateOnBorrow(\\n            pool,\\n            _user,\\n            _amount,\\n            balanceIncrease,\\n            _borrowFee,\\n            _rateMode\\n        );\\n\\n        updatePoolInterestRates(pool, 0, _amount);\\n\\n        return (getUserCurrentBorrowRate(pool, _user), balanceIncrease);\\n    }\\n\\n    function updateStateOnRepay(\\n        address _pool,\\n        address _user,\\n        uint256 _paybackAmountMinusFees,\\n        uint256 _originationFeeRepaid,\\n        uint256 _balanceIncrease,\\n        bool _repaidWholeLoan\\n    ) external {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n\\n        updatePoolStateOnRepay(\\n            pool,\\n            _user,\\n            _paybackAmountMinusFees,\\n            _balanceIncrease\\n        );\\n        updateUserStateOnRepay(\\n            pool,\\n            _user,\\n            _paybackAmountMinusFees,\\n            _originationFeeRepaid,\\n            _balanceIncrease,\\n            _repaidWholeLoan\\n        );\\n\\n        updatePoolInterestRates(pool, _paybackAmountMinusFees, 0);\\n    }\\n\\n    function updatePoolStateOnRepay(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _paybackAmountMinusFees,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        updateCumulativeIndexes(_pool);\\n\\n        LibFacet.InterestRateMode borrowMode = getUserCurrentBorrowRateMode(\\n            _pool,\\n            _user\\n        );\\n        if (borrowMode == LibFacet.InterestRateMode.VARIABLE) {\\n            increaseTotalVariableBorrows(_pool, _balanceIncrease);\\n            decreaseTotalVariableBorrows(_pool, _paybackAmountMinusFees);\\n        } else {}\\n    }\\n\\n    function updateUserStateOnRepay(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _paybackAmountMinusFees,\\n        uint256 _originationFeeRepaid,\\n        uint256 _balanceIncrease,\\n        bool _repaidWholeLoan\\n    ) internal {\\n        LibFacet.UserPoolData storage user = _pool.users[_user];\\n        user.principalBorrowBalance =\\n            user.principalBorrowBalance +\\n            _balanceIncrease -\\n            _paybackAmountMinusFees;\\n        user.lastCumulatedVariableBorrowIndex = _pool\\n            .lastCumulatedVariableBorrowIndex;\\n        if (_repaidWholeLoan) {\\n            user.rates.stableBorrowRate = 0;\\n            user.rates.variableBorrowRate = 0;\\n        }\\n        user.originationFee = user.originationFee - _originationFeeRepaid;\\n        user.lastUpdatedTimestamp = block.timestamp;\\n    }\\n\\n    function updatePoolStateOnBorrow(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _principalBorrowBalance,\\n        uint256 _balanceIncrease,\\n        uint256 _amountBorrowed,\\n        LibFacet.InterestRateMode _rateMode\\n    ) internal {\\n        updateCumulativeIndexes(_pool);\\n        updatePoolTotalBorrows(\\n            _pool,\\n            _user,\\n            _principalBorrowBalance,\\n            _balanceIncrease,\\n            _amountBorrowed,\\n            _rateMode\\n        );\\n    }\\n\\n    // TODO: ADD previous values of indexes to the Pool and UserPoolData structs.\\n    function updateUserStateOnBorrow(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _amountBorrowed,\\n        uint256 _balanceIncrease,\\n        uint256 _fee,\\n        LibFacet.InterestRateMode _rateMode\\n    ) internal {\\n        LibFacet.UserPoolData storage user = _pool.users[_user];\\n\\n        if (_rateMode == LibFacet.InterestRateMode.STABLE) {} else if (\\n            _rateMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            user.rates.stableBorrowRate = 0;\\n            user.lastCumulatedVariableBorrowIndex = _pool\\n                .lastCumulatedVariableBorrowIndex;\\n        } else {\\n            revert(\\\"Invalid borrow mode.\\\");\\n        }\\n\\n        user.principalBorrowBalance += _balanceIncrease + _amountBorrowed;\\n        user.originationFee = user.originationFee + _fee;\\n        user.lastUpdatedTimestamp = block.timestamp;\\n    }\\n\\n    function updatePoolTotalBorrows(\\n        LibFacet.Pool storage _pool,\\n        address _user,\\n        uint256 _principalBorrowBalance,\\n        uint256 _balanceIncrease,\\n        uint256 _amountBorrowed,\\n        LibFacet.InterestRateMode _newRateMode\\n    ) internal {\\n        LibFacet.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\\n                _pool.users[_user]\\n            );\\n        if (previousRateMode == LibFacet.InterestRateMode.STABLE) {} else if (\\n            previousRateMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            decreaseTotalVariableBorrows(_pool, _principalBorrowBalance);\\n        }\\n\\n        uint256 newPrincipalAmount = _principalBorrowBalance +\\n            _amountBorrowed +\\n            _balanceIncrease;\\n        if (_newRateMode == LibFacet.InterestRateMode.STABLE) {} else if (\\n            _newRateMode == LibFacet.InterestRateMode.VARIABLE\\n        ) {\\n            increaseTotalVariableBorrows(_pool, newPrincipalAmount);\\n        } else {\\n            revert(\\\"Invalid new borrow rate mode.\\\");\\n        }\\n    }\\n\\n    function decreaseTotalVariableBorrows(\\n        LibFacet.Pool storage _pool,\\n        uint256 _amount\\n    ) internal {\\n        require(\\n            _pool.totalVariableBorrowLiquidity >= _amount,\\n            \\\"The amount that is being subtracted from the variable borrows is incorrect.\\\"\\n        );\\n        _pool.totalVariableBorrowLiquidity -= _amount;\\n    }\\n\\n    function increaseTotalVariableBorrows(\\n        LibFacet.Pool storage _pool,\\n        uint256 _amount\\n    ) internal {\\n        _pool.totalVariableBorrowLiquidity += _amount;\\n    }\\n\\n    function getUserCurrentBorrowRateMode(LibFacet.UserPoolData memory _user)\\n        internal\\n        pure\\n        returns (LibFacet.InterestRateMode)\\n    {\\n        if (_user.principalBorrowBalance == 0)\\n            return LibFacet.InterestRateMode.NONE;\\n\\n        return\\n            _user.rates.stableBorrowRate > 0\\n                ? LibFacet.InterestRateMode.STABLE\\n                : LibFacet.InterestRateMode.VARIABLE;\\n    }\\n\\n    function updateCumulativeIndexes(LibFacet.Pool storage _pool) internal {\\n        if (_pool.totalBorrowedLiquidity > 0) {\\n            _pool.cumulatedLiquidityIndex = calculateLinearInterest(\\n                _pool.rates.currentLiquidityRate,\\n                _pool.lastUpdatedTimestamp\\n            ).rayMul(_pool.lastCumulatedLiquidityIndex);\\n            _pool.cumulatedVariableBorrowIndex = calculateCompoundedInterest(\\n                _pool.rates.variableBorrowRate,\\n                LibFacet.lpcStorage().SECONDS_IN_YEAR,\\n                block.timestamp,\\n                _pool.lastUpdatedTimestamp\\n            ).rayMul(_pool.lastCumulatedVariableBorrowIndex);\\n        }\\n    }\\n\\n    function updatePoolInterestRates(\\n        LibFacet.Pool storage _pool,\\n        uint256 _liquidityAdded,\\n        uint256 _liquidityTaken\\n    ) internal {\\n        (\\n            _pool.rates.variableBorrowRate,\\n            _pool.rates.currentLiquidityRate\\n        ) = calculateInterestRates(\\n            _pool.totalLiquidity + _liquidityAdded - _liquidityTaken,\\n            _pool.totalVariableBorrowLiquidity,\\n            _pool.rates.interestRateSlopeBelow,\\n            _pool.rates.interestRateSlopeAbove,\\n            _pool.rates.baseVariableBorrowRate,\\n            _pool.rates.targetUtilisationRate\\n        );\\n        _pool.lastUpdatedTimestamp = block.timestamp;\\n    }\\n\\n    function calculateInterestRates(\\n        uint256 _totalLiquidity,\\n        uint256 _totalVariableBorrows,\\n        uint256 _variableRateSlope1,\\n        uint256 _VariableRateSlope2,\\n        uint256 _baseVariableBorrowRate,\\n        uint256 _optimalUtilizationRate\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256 currentVariableBorrowRate,\\n            uint256 currentLiquidityRate\\n        )\\n    {\\n        uint256 totalBorrows = _totalVariableBorrows; /// @dev + totalStableBorrows\\n        uint256 utilizationRate = (_totalLiquidity == 0 && totalBorrows == 0)\\n            ? 0\\n            : totalBorrows.rayDiv(_totalLiquidity);\\n        if (utilizationRate > _optimalUtilizationRate) {\\n            uint256 excessUtilizationRateRatio = (utilizationRate -\\n                _optimalUtilizationRate).rayDiv(1 - _optimalUtilizationRate);\\n            currentVariableBorrowRate =\\n                _baseVariableBorrowRate +\\n                _variableRateSlope1 +\\n                (_VariableRateSlope2.rayMul(excessUtilizationRateRatio));\\n        } else {\\n            currentVariableBorrowRate =\\n                _baseVariableBorrowRate +\\n                (\\n                    utilizationRate.rayDiv(_optimalUtilizationRate).rayMul(\\n                        _variableRateSlope1\\n                    )\\n                );\\n        }\\n        currentLiquidityRate = calculateOverallBorrowRate(\\n            _totalVariableBorrows,\\n            currentVariableBorrowRate\\n        ).rayMul(utilizationRate);\\n    }\\n\\n    function calculateOverallBorrowRate(\\n        uint256 _totalVariableBorrows,\\n        uint256 _currentVariableBorrowRate\\n    ) internal pure returns (uint256) {\\n        uint256 totalBorrows = _totalVariableBorrows; /// TODO: + _totalStableBorrows\\n        if (totalBorrows == 0) return 0;\\n\\n        uint256 weightedVariableRate = _totalVariableBorrows.wadToRay().rayMul(\\n            _currentVariableBorrowRate\\n        );\\n\\n        return weightedVariableRate.rayDiv(totalBorrows.wadToRay());\\n    }\\n\\n    function getUserBorrowBalances(address _pool, address _user)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        LibFacet.UserPoolData storage user = pool.users[_user];\\n        if (user.principalBorrowBalance == 0) return (0, 0, 0);\\n\\n        uint256 compoundedBalance = getCompoundedBorrowBalance(user, pool);\\n        return (\\n            user.principalBorrowBalance,\\n            compoundedBalance,\\n            compoundedBalance - user.principalBorrowBalance\\n        );\\n    }\\n\\n    function getUserOriginationFee(address _pool, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].users[_user].originationFee;\\n    }\\n\\n    /// @dev calculates interest using compounded interest rate formula\\n    function calculateCompoundedInterest(\\n        uint256 _variableBorrowRate,\\n        uint256 _secondsInAYear,\\n        uint256 _timestamp,\\n        uint256 _lastUpdatedTimestamp\\n    ) internal pure returns (uint256) {\\n        uint256 ratePerSecond = _variableBorrowRate.rayDiv(_secondsInAYear);\\n        return\\n            ratePerSecond +\\n            (WadRayMath.RAY.rayPow(_timestamp - _lastUpdatedTimestamp));\\n    }\\n\\n    /// @dev calculates interest using linear interest rate formula\\n    function calculateLinearInterest(\\n        uint256 _currentLiquidityRate,\\n        uint256 _lastUpdatedTimestamp\\n    ) internal view returns (uint256) {\\n        uint256 timeDelta = calculateTimeDelta(\\n            block.timestamp,\\n            _lastUpdatedTimestamp,\\n            LibFacet.lpcStorage().SECONDS_IN_YEAR\\n        );\\n        return _currentLiquidityRate.rayMul(timeDelta) + WadRayMath.RAY;\\n    }\\n\\n    function calculateTimeDelta(\\n        uint256 _timestamp,\\n        uint256 _lastUpdatedTimestamp,\\n        uint256 _secondsInAYear\\n    ) internal pure returns (uint256) {\\n        return\\n            (_timestamp - _lastUpdatedTimestamp).wadToRay().rayDiv(\\n                _secondsInAYear.wadToRay()\\n            );\\n    }\\n\\n    //function calculateAvailableLiquidity(LibFacet.Pool storage pool)\\n    //    internal\\n    //    view\\n    //    returns (uint256)\\n    //{\\n    //    return pool.totalLiquidity - pool.totalBorrowedLiquidity;\\n    //}\\n\\n    function getCompoundedBorrowBalance(\\n        LibFacet.UserPoolData storage _user,\\n        LibFacet.Pool storage _pool\\n    ) internal view returns (uint256) {\\n        if (_user.principalBorrowBalance == 0) return 0;\\n\\n        uint256 principalBorrowBalance = _user\\n            .principalBorrowBalance\\n            .wadToRay();\\n        uint256 compoundedBalance = 0;\\n        uint256 cumulatedInterest = 0;\\n\\n        if (_user.rates.stableBorrowRate > 0) {} else {\\n            // variable interest\\n            cumulatedInterest = calculateCompoundedInterest(\\n                _pool.rates.variableBorrowRate,\\n                LibFacet.lpcStorage().SECONDS_IN_YEAR,\\n                block.timestamp,\\n                _pool.lastUpdatedTimestamp\\n            ).rayMul(_pool.lastCumulatedVariableBorrowIndex).rayDiv(\\n                    _user.lastCumulatedVariableBorrowIndex\\n                );\\n        }\\n\\n        compoundedBalance = principalBorrowBalance\\n            .rayMul(cumulatedInterest)\\n            .rayToWad();\\n\\n        if (compoundedBalance == _user.principalBorrowBalance)\\n            if (_user.lastUpdatedTimestamp != block.timestamp)\\n                return _user.principalBorrowBalance + 1 wei;\\n\\n        return compoundedBalance;\\n    }\\n\\n    function getUserCurrentBorrowRate(\\n        LibFacet.Pool storage _pool,\\n        address _user\\n    ) internal view returns (uint256) {\\n        LibFacet.InterestRateMode rateMode = getUserCurrentBorrowRateMode(\\n            _pool.users[_user]\\n        );\\n\\n        if (rateMode == LibFacet.InterestRateMode.NONE) return 0;\\n\\n        return\\n            rateMode == LibFacet.InterestRateMode.STABLE\\n                ? 0\\n                : _pool.rates.variableBorrowRate;\\n    }\\n\\n    function getUserCurrentBorrowRateMode(\\n        LibFacet.Pool storage _pool,\\n        address _user\\n    ) internal view returns (LibFacet.InterestRateMode) {\\n        return _pool.users[_user].rates.rateMode;\\n    }\\n\\n    function getUserPoolData(address _pool, address _user)\\n        public\\n        view\\n        returns (\\n            uint256 compoundedLiquidityBalance,\\n            uint256 compoundedBorrowBalance,\\n            uint256 originationFee,\\n            bool userUsesPoolAsCollateral\\n        )\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        uint256 assetBalance = pool.users[_user].liquidityProvided;\\n        if (pool.users[_user].principalBorrowBalance == 0)\\n            return (assetBalance, 0, 0, pool.users[_user].useAsCollateral);\\n\\n        return (\\n            assetBalance,\\n            getCompoundedBorrowBalance(pool.users[_user], pool),\\n            pool.users[_user].originationFee,\\n            pool.users[_user].useAsCollateral\\n        );\\n    }\\n\\n    function getPoolConfiguration(address _pool)\\n        public\\n        view\\n        returns (\\n            uint256 reserveDecimals,\\n            uint256 baseLTV,\\n            uint256 liquidationTHreshold,\\n            bool usageAsCollateralEnabled\\n        )\\n    {\\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\\n        return (\\n            pool.decimals,\\n            pool.baseLTV,\\n            pool.liquidationThreshold,\\n            pool.isUsableAsCollateral\\n        );\\n    }\\n\\n    //function getHealthFactor(\\n    //    uint256 _collateralEth,\\n    //    uint256 _liquidationThreshold,\\n    //    uint256 _compoundedBorrowBalance\\n    //) internal pure returns (uint256) {\\n    //    return\\n    //        _collateralEth.rayMul(_liquidationThreshold).rayDiv(\\n    //            _compoundedBorrowBalance\\n    //        );\\n    //}\\n\\n    function getPoolDecimals(address _pool) public view returns (uint256) {\\n        return LibFacet.lpcStorage().pools[_pool].decimals;\\n    }\\n\\n    function getPoolAvailableLiquidity(address _pool)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].totalLiquidity;\\n    }\\n\\n    function isPoolBorrowingEnabled(address _pool) public view returns (bool) {\\n        return LibFacet.lpcStorage().pools[_pool].isBorrowingEnabled;\\n    }\\n\\n    function isPoolUsageAsCollateralEnabled(address _pool)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return LibFacet.lpcStorage().pools[_pool].isUsableAsCollateral;\\n    }\\n\\n    function setUserUsePoolAsCollateralInternal(\\n        LibFacet.UserPoolData storage _user,\\n        bool _useAsCollateral\\n    ) internal {\\n        _user.useAsCollateral = _useAsCollateral;\\n    }\\n\\n    function transferToPool(\\n        address _pool,\\n        address _user,\\n        uint256 _amount\\n    ) public payable {\\n        if (_pool == LibFacet.facetStorage().ethAddress) {\\n            (bool success, ) = _pool.call{value: _amount}(\\\"\\\");\\n            require(success, \\\"Error while sending ETH.\\\");\\n        } else {\\n            console.log(LibFacet.facetStorage().ethAddress);\\n            ERC20(_pool).transferFrom(_user, _pool, _amount);\\n        }\\n    }\\n\\n    function transferToUser(\\n        address _pool,\\n        address _user,\\n        uint256 _amount\\n    ) public {\\n        if (_pool == LibFacet.facetStorage().ethAddress) {\\n            (bool success, ) = _user.call{value: _amount}(\\\"\\\");\\n            require(success, \\\"Error while sending ETH.\\\");\\n        } else {\\n            ERC20(_pool).transferFrom(_pool, _user, _amount);\\n        }\\n    }\\n\\n    function transferToFeeCollector(\\n        address _token,\\n        address _user,\\n        uint256 _amount\\n    ) public payable {\\n        address feeProvider = LibFacet.facetStorage().feeProviderAddress;\\n        if (_token != LibFacet.facetStorage().ethAddress) {\\n            require(\\n                msg.value == 0,\\n                \\\"User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction\\\"\\n            );\\n            ERC20(_token).transferFrom(_user, feeProvider, _amount);\\n        } else {\\n            require(\\n                msg.value >= _amount,\\n                \\\"The amount and the value sent to deposit do not match\\\"\\n            );\\n            //solium-disable-next-line\\n            (bool result, ) = feeProvider.call{value: _amount}(\\\"\\\");\\n            require(result, \\\"Transfer of ETH failed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa33990d49ca1f788750452b80ab3bb18252fca7b6697aff814fa3c9d2ed4b995\",\"license\":\"No-License\"},\"contracts/libraries/LibFacet.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"../LendingPoolCore.sol\\\";\\nimport \\\"../DataProvider.sol\\\";\\nimport \\\"../FeeProvider.sol\\\";\\nimport \\\"../mocks/PriceFeed.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary LibFacet {\\n    bytes32 constant LENDING_POOL_CORE_STORAGE_POSITION =\\n        keccak256(\\\"diamonds.standart.lending.pool.core.storage\\\");\\n    bytes32 constant FACET_STORAGE_POSITION =\\n        keccak256(\\\"diamonds.standart.facet.storage\\\");\\n\\n    // user data tied to a specific pool\\n    struct UserPoolData {\\n        uint256 liquidityProvided;\\n        uint256 principalBorrowBalance;\\n        uint256 cumulatedVariableBorrowIndex;\\n        uint256 lastCumulatedVariableBorrowIndex;\\n        uint256 compoundedBorrowBalance;\\n        uint256 collateralETHBalance;\\n        uint256 liquidationThreshold;\\n        uint256 originationFee;\\n        uint256 healthFactor;\\n        uint256 lastUpdatedTimestamp;\\n        bool useAsCollateral;\\n        UserInterestRate rates;\\n    }\\n\\n    struct Pool {\\n        uint256 decimals;\\n        uint256 totalLiquidity;\\n        uint256 totalBorrowedLiquidity;\\n        uint256 totalVariableBorrowLiquidity;\\n        uint256 cumulatedLiquidityIndex; // interest cumulated by the reserve during the time interval Dt\\n        uint256 lastCumulatedLiquidityIndex;\\n        uint256 reserveNormalizedIncome; // Ongoing interest cumulated by the reserve\\n        uint256 cumulatedVariableBorrowIndex;\\n        uint256 lastCumulatedVariableBorrowIndex;\\n        uint256 baseLTV;\\n        uint256 loanToValue;\\n        uint256 liquidationThreshold;\\n        uint256 liquidationBonus; // represented in percentage\\n        uint256 lastUpdatedTimestamp;\\n        bool isBorrowingEnabled;\\n        bool isUsableAsCollateral;\\n        bool isActive;\\n        bool isFreezed; // only allow repays and redeems, but not deposits, new borrowings or rate swap.\\n        InterestRate rates;\\n        mapping(address => UserPoolData) users;\\n        address asset;\\n        address[] allUsers;\\n    }\\n\\n    struct LPCStorage {\\n        mapping(address => Pool) pools;\\n        address[] allPools;\\n        uint256 SECONDS_IN_YEAR;\\n    }\\n\\n    struct FacetStorage {\\n        address ethAddress;\\n        address lpcAddress;\\n        address dataProviderAddress;\\n        address priceFeedAddress;\\n        address feeProviderAddress;\\n    }\\n\\n    struct InterestRate {\\n        InterestRateMode rateMode;\\n        uint256 targetUtilisationRate;\\n        uint256 interestRateSlopeBelow; // constant representing the scaling of the interest rate vs the utilization.\\n        uint256 interestRateSlopeAbove;\\n        uint256 baseVariableBorrowRate; // constant for totalBorrows = 0. Expressed in ray\\n        uint256 variableBorrowRate;\\n        uint256 overallBorrowRate; // (VariableBorrowRate * TotalVariableBorrows) / totalBorrows\\n        uint256 currentLiquidityRate; // overallBorrowRate * utilizationRate\\n    }\\n\\n    struct UserInterestRate {\\n        InterestRateMode rateMode;\\n        uint256 variableBorrowRate;\\n        uint256 stableBorrowRate;\\n        uint256 cumulatedVariableBorrowIndex;\\n    }\\n\\n    enum TokenVolatility {\\n        LOW,\\n        HIGH\\n    }\\n\\n    enum InterestRateMode {\\n        VARIABLE,\\n        STABLE,\\n        NONE\\n    }\\n\\n    function lpcStorage() internal pure returns (LPCStorage storage lpcs) {\\n        bytes32 position = LENDING_POOL_CORE_STORAGE_POSITION;\\n        assembly {\\n            lpcs.slot := position\\n        }\\n    }\\n\\n    function facetStorage() internal pure returns (FacetStorage storage fs) {\\n        bytes32 position = FACET_STORAGE_POSITION;\\n        assembly {\\n            fs.slot := position\\n        }\\n    }\\n\\n    function getDataProvider() internal view returns (DataProvider) {\\n        return DataProvider(facetStorage().dataProviderAddress);\\n    }\\n\\n    function getFeeProvider() internal view returns (FeeProvider) {\\n        return FeeProvider(facetStorage().feeProviderAddress);\\n    }\\n\\n    function getPriceFeed() internal view returns (PriceFeed) {\\n        return PriceFeed(facetStorage().priceFeedAddress);\\n    }\\n}\\n\",\"keccak256\":\"0x74903265a4c640e60835aa73b99ef925ae097616c993fdde3ed1355539092278\",\"license\":\"No-License\"},\"contracts/libraries/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n **/\\nlibrary WadRayMath {\\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a*b, in wad\\n     **/\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n        assembly {\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(\\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a/b, in wad\\n     **/\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n        assembly {\\n            if or(\\n                iszero(b),\\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, WAD), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raymul b\\n     **/\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n        assembly {\\n            if iszero(\\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, b), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raydiv b\\n     **/\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n        assembly {\\n            if or(\\n                iszero(b),\\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            c := div(add(mul(a, RAY), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @return b = a converted to wad, rounded half up to the nearest wad\\n     **/\\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := div(a, WAD_RAY_RATIO)\\n            let remainder := mod(a, WAD_RAY_RATIO)\\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\\n                b := add(b, 1)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @return b = a converted in ray\\n     **/\\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n        // to avoid overflow, b/WAD_RAY_RATIO == a\\n        assembly {\\n            b := mul(a, WAD_RAY_RATIO)\\n\\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rayMul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rayMul(z, x);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x74d16d29afcc5dcb605b47389af1535fedacd849714a76cdbac9700295594746\",\"license\":\"BUSL-1.1\"},\"contracts/mocks/PriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: No-License\\npragma solidity 0.8.17;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract PriceFeed {\\n    address internal owner;\\n    mapping(address => AggregatorV3Interface) internal priceFeeds;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == owner,\\n            \\\"Only the owner of this smart contract can execute this action.\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    function addAssetOracle(address _asset, address _oracle)\\n        external\\n        onlyOwner\\n    {\\n        priceFeeds[_asset] = AggregatorV3Interface(_oracle);\\n    }\\n\\n    function getAssetPrice(address _asset) external view returns (uint256) {\\n        (, int256 price, , , ) = priceFeeds[_asset].latestRoundData();\\n        return uint256(price);\\n    }\\n}\\n\",\"keccak256\":\"0xebad21912db523c5e74ae2322211a33f5057f130fd579428e8317b50a5c69f84\",\"license\":\"No-License\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611201806100206000396000f3fe60806040526004361061003f5760003560e01c80630e6dfcd51461004457806322867d78146100665780638340f54914610079578063b6e82e031461008c575b600080fd5b34801561005057600080fd5b5061006461005f366004610eca565b6100ac565b005b610064610074366004610f06565b610237565b610064610087366004610eca565b6106dc565b34801561009857600080fd5b506100646100a7366004610f30565b610824565b6001600160a01b03831660009081527f66cfe6d1341bbca11619797516c7fbf0624d144c78b9a40a4a3b4fb518fc11b66020526040902060018101543091908311156101485760405162461bcd60e51b815260206004820152603260248201526000805160206111ac83398151915260448201527130b4b630b13632903a37903932b232b2b69760711b60648201526084015b60405180910390fd5b6001600160a01b0384811660009081526017830160205260409081902054905163afcdbea360e01b815287831660048201523360248201526044810186905290851460648201529083169063afcdbea390608401600060405180830381600087803b1580156101b657600080fd5b505af11580156101ca573d6000803e3d6000fd5b505060405163fa93b2a560e01b81526001600160a01b038516925063fa93b2a591506101fe90889088908890600401610f74565b600060405180830381600087803b15801561021857600080fd5b505af115801561022c573d6000803e3d6000fd5b505050505050505050565b6000309050610286604051806101000160405280600081526020016000815260200160008152602001600015158152602001600081526020016000815260200160008152602001600081525090565b604051639fb8afcd60e01b81526001600160a01b03831690639fb8afcd906102b49087903390600401610f98565b606060405180830381865afa1580156102d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f59190610fb2565b604080850191909152602084019190915290825251633faacc6b60e21b81526001600160a01b0383169063feab31ac906103359087903390600401610f98565b602060405180830381865afa158015610352573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103769190610fe0565b60e08201526001600160a01b03841661038d610dfc565b546001600160a01b031614606082015260208101516104015760405162461bcd60e51b815260206004820152602a60248201527f546865207573657220646f6573206e746f206861766520616e7920626f72726f6044820152693b903832b73234b7339760b11b606482015260840161013f565b8060e001518160200151610415919061100f565b60808201526060810151158061042f575080608001513410155b6104925760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e74206d73672e76616c75652073656e6420666f722060448201526d3a3432903932b830bcb6b2b73a1760911b606482015260840161013f565b8060e00151816080015111610573576080810151604080830151905163da12d96f60e01b81526001600160a01b0385169263da12d96f926104de92899233926000928390600401611028565b600060405180830381600087803b1580156104f857600080fd5b505af115801561050c573d6000803e3d6000fd5b50505050816001600160a01b0316639a881174826060015161052f576000610535565b82608001515b863385608001516040518563ffffffff1660e01b815260040161055a93929190610f74565b6000604051808303818588803b15801561021857600080fd5b8060e001518160800151610587919061105e565b60a0820181905260e08201516040808401516020850151915163da12d96f60e01b81526001600160a01b0387169463da12d96f946105d0948b9433949091841490600401611028565b600060405180830381600087803b1580156105ea57600080fd5b505af11580156105fe573d6000803e3d6000fd5b5050505060e08101511561068957816001600160a01b0316639a881174826060015161062b576000610631565b8260e001515b86338560e001516040518563ffffffff1660e01b815260040161065693929190610f74565b6000604051808303818588803b15801561066f57600080fd5b505af1158015610683573d6000803e3d6000fd5b50505050505b816001600160a01b031663dd2c99f782606001516106a85760006106b7565b60e08301516106b7903461105e565b86338560a001516040518563ffffffff1660e01b815260040161055a93929190610f74565b6106e4610dfc565b546001600160a01b0384811691161461076d576040516370a0823160e01b815281906001600160a01b038516906370a0823190610725908690600401611071565b602060405180830381865afa158015610742573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107669190610fe0565b101561077c565b80826001600160a01b03163110155b6107c65760405162461bcd60e51b815260206004820152601b60248201527a24b739bab33334b1b4b2b73a103a37b5b2b7103130b630b731b29760291b604482015260640161013f565b60405163f34662dd60e01b8152309063f34662dd906107ed90869033908690600401610f74565b600060405180830381600087803b15801561080757600080fd5b505af115801561081b573d6000803e3d6000fd5b50505050505050565b61082c610e20565b60405163a5df1b2960e01b81523090819063a5df1b2990610851908890600401611071565b602060405180830381865afa15801561086e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108929190611095565b6108e95760405162461bcd60e51b815260206004820152602260248201527f506f6f6c206973206e6f7420656e61626c656420666f7220626f72726f77696e604482015261339760f11b606482015260840161013f565b60008360028111156108fd576108fd6110b7565b148061091a57506001836002811115610918576109186110b7565b145b6109725760405162461bcd60e51b815260206004820152602360248201527f496e76616c696420696e7465726573742072617465206d6f64652073656c65636044820152621d195960ea1b606482015260840161013f565b6040516361e9e5c760e11b815284906001600160a01b0383169063c3d3cb8e906109a0908990600401611071565b602060405180830381865afa1580156109bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e19190610fe0565b1015610a3a5760405162461bcd60e51b815260206004820152603460248201526000805160206111ac83398151915260448201527330b4b630b136329034b7103a3432903837b7b61760611b606482015260840161013f565b6040516370fd015d60e11b8152309063e1fa02ba90610a5d903390600401611071565b61010060405180830381865afa158015610a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a9f91906110cd565b15156101e08a0152506040880152602087015261010086015260e085015260c0840181905215159050610b135760405162461bcd60e51b815260206004820152601c60248201527b2a34329031b7b63630ba32b930b6103130b630b731b29034b990181760211b604482015260640161013f565b816101e0015115610b765760405162461bcd60e51b815260206004820152602760248201527f54686520626f72726f7765722063616e20616c7265616479206265206c69717560448201526634b230ba32b21760c91b606482015260840161013f565b60405163249bbe9160e01b815260048101859052309063249bbe9190602401602060405180830381865afa158015610bb2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bd69190610fe0565b60608301819052610c345760405162461bcd60e51b815260206004820152602260248201527f54686520616d6f756e7420746f20626f72726f7720697320746f6f20736d616c604482015261361760f11b606482015260840161013f565b606082015160e083015161010084015160208501516040516312737c3360e01b81526001600160a01b038a1660048201526024810189905260448101949094526064840192909252608483015260a482015230906312737c339060c401602060405180830381865afa158015610cae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd29190610fe0565b60a0830181905260c08301511015610d435760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e7420636f6c6c61746572616c20746f20636f76657260448201526d1030903732bb903137b93937bb9760911b606482015260840161013f565b60608201516101c0830151604051630deb1bf960e21b81526001600160a01b038416926337ac6fe492610d7e928a9233928b92600401611133565b60408051808303816000875af1158015610d9c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc09190611187565b6101208401526101a083015260405163fa93b2a560e01b81526001600160a01b0382169063fa93b2a5906101fe90889033908990600401610f74565b7fff5923912191a1cc1ce52c1e63600d3ff20a63ae0f4211e3199b7ba72a991b5a90565b604051806102000160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160006002811115610ea157610ea16110b7565b8152600060209091015290565b80356001600160a01b0381168114610ec557600080fd5b919050565b600080600060608486031215610edf57600080fd5b610ee884610eae565b9250610ef660208501610eae565b9150604084013590509250925092565b60008060408385031215610f1957600080fd5b610f2283610eae565b946020939093013593505050565b600080600060608486031215610f4557600080fd5b610f4e84610eae565b925060208401359150604084013560038110610f6957600080fd5b809150509250925092565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b0392831681529116602082015260400190565b600080600060608486031215610fc757600080fd5b8351925060208401519150604084015190509250925092565b600060208284031215610ff257600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561102257611022610ff9565b92915050565b6001600160a01b03968716815294909516602085015260408401929092526060830152608082015290151560a082015260c00190565b8181038181111561102257611022610ff9565b6001600160a01b0391909116815260200190565b80518015158114610ec557600080fd5b6000602082840312156110a757600080fd5b6110b082611085565b9392505050565b634e487b7160e01b600052602160045260246000fd5b600080600080600080600080610100898b0312156110ea57600080fd5b885197506020890151965060408901519550606089015194506080890151935060a0890151925060c0890151915061112460e08a01611085565b90509295985092959890939650565b6001600160a01b03868116825285166020820152604081018490526060810183905260a081016003831061117757634e487b7160e01b600052602160045260246000fd5b8260808301529695505050505050565b6000806040838503121561119a57600080fd5b50508051602090910151909290915056fe5468657265206973206e6f7420656e6f756768206c6971756964697479206176a2646970667358221220cb91ea52c2166b34d4ca3f659aba6d0d20ff821f9f6647f84bf6d95b2feee1fd64736f6c63430008110033",
  "deployedBytecode": "0x60806040526004361061003f5760003560e01c80630e6dfcd51461004457806322867d78146100665780638340f54914610079578063b6e82e031461008c575b600080fd5b34801561005057600080fd5b5061006461005f366004610eca565b6100ac565b005b610064610074366004610f06565b610237565b610064610087366004610eca565b6106dc565b34801561009857600080fd5b506100646100a7366004610f30565b610824565b6001600160a01b03831660009081527f66cfe6d1341bbca11619797516c7fbf0624d144c78b9a40a4a3b4fb518fc11b66020526040902060018101543091908311156101485760405162461bcd60e51b815260206004820152603260248201526000805160206111ac83398151915260448201527130b4b630b13632903a37903932b232b2b69760711b60648201526084015b60405180910390fd5b6001600160a01b0384811660009081526017830160205260409081902054905163afcdbea360e01b815287831660048201523360248201526044810186905290851460648201529083169063afcdbea390608401600060405180830381600087803b1580156101b657600080fd5b505af11580156101ca573d6000803e3d6000fd5b505060405163fa93b2a560e01b81526001600160a01b038516925063fa93b2a591506101fe90889088908890600401610f74565b600060405180830381600087803b15801561021857600080fd5b505af115801561022c573d6000803e3d6000fd5b505050505050505050565b6000309050610286604051806101000160405280600081526020016000815260200160008152602001600015158152602001600081526020016000815260200160008152602001600081525090565b604051639fb8afcd60e01b81526001600160a01b03831690639fb8afcd906102b49087903390600401610f98565b606060405180830381865afa1580156102d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f59190610fb2565b604080850191909152602084019190915290825251633faacc6b60e21b81526001600160a01b0383169063feab31ac906103359087903390600401610f98565b602060405180830381865afa158015610352573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103769190610fe0565b60e08201526001600160a01b03841661038d610dfc565b546001600160a01b031614606082015260208101516104015760405162461bcd60e51b815260206004820152602a60248201527f546865207573657220646f6573206e746f206861766520616e7920626f72726f6044820152693b903832b73234b7339760b11b606482015260840161013f565b8060e001518160200151610415919061100f565b60808201526060810151158061042f575080608001513410155b6104925760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e74206d73672e76616c75652073656e6420666f722060448201526d3a3432903932b830bcb6b2b73a1760911b606482015260840161013f565b8060e00151816080015111610573576080810151604080830151905163da12d96f60e01b81526001600160a01b0385169263da12d96f926104de92899233926000928390600401611028565b600060405180830381600087803b1580156104f857600080fd5b505af115801561050c573d6000803e3d6000fd5b50505050816001600160a01b0316639a881174826060015161052f576000610535565b82608001515b863385608001516040518563ffffffff1660e01b815260040161055a93929190610f74565b6000604051808303818588803b15801561021857600080fd5b8060e001518160800151610587919061105e565b60a0820181905260e08201516040808401516020850151915163da12d96f60e01b81526001600160a01b0387169463da12d96f946105d0948b9433949091841490600401611028565b600060405180830381600087803b1580156105ea57600080fd5b505af11580156105fe573d6000803e3d6000fd5b5050505060e08101511561068957816001600160a01b0316639a881174826060015161062b576000610631565b8260e001515b86338560e001516040518563ffffffff1660e01b815260040161065693929190610f74565b6000604051808303818588803b15801561066f57600080fd5b505af1158015610683573d6000803e3d6000fd5b50505050505b816001600160a01b031663dd2c99f782606001516106a85760006106b7565b60e08301516106b7903461105e565b86338560a001516040518563ffffffff1660e01b815260040161055a93929190610f74565b6106e4610dfc565b546001600160a01b0384811691161461076d576040516370a0823160e01b815281906001600160a01b038516906370a0823190610725908690600401611071565b602060405180830381865afa158015610742573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107669190610fe0565b101561077c565b80826001600160a01b03163110155b6107c65760405162461bcd60e51b815260206004820152601b60248201527a24b739bab33334b1b4b2b73a103a37b5b2b7103130b630b731b29760291b604482015260640161013f565b60405163f34662dd60e01b8152309063f34662dd906107ed90869033908690600401610f74565b600060405180830381600087803b15801561080757600080fd5b505af115801561081b573d6000803e3d6000fd5b50505050505050565b61082c610e20565b60405163a5df1b2960e01b81523090819063a5df1b2990610851908890600401611071565b602060405180830381865afa15801561086e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108929190611095565b6108e95760405162461bcd60e51b815260206004820152602260248201527f506f6f6c206973206e6f7420656e61626c656420666f7220626f72726f77696e604482015261339760f11b606482015260840161013f565b60008360028111156108fd576108fd6110b7565b148061091a57506001836002811115610918576109186110b7565b145b6109725760405162461bcd60e51b815260206004820152602360248201527f496e76616c696420696e7465726573742072617465206d6f64652073656c65636044820152621d195960ea1b606482015260840161013f565b6040516361e9e5c760e11b815284906001600160a01b0383169063c3d3cb8e906109a0908990600401611071565b602060405180830381865afa1580156109bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e19190610fe0565b1015610a3a5760405162461bcd60e51b815260206004820152603460248201526000805160206111ac83398151915260448201527330b4b630b136329034b7103a3432903837b7b61760611b606482015260840161013f565b6040516370fd015d60e11b8152309063e1fa02ba90610a5d903390600401611071565b61010060405180830381865afa158015610a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a9f91906110cd565b15156101e08a0152506040880152602087015261010086015260e085015260c0840181905215159050610b135760405162461bcd60e51b815260206004820152601c60248201527b2a34329031b7b63630ba32b930b6103130b630b731b29034b990181760211b604482015260640161013f565b816101e0015115610b765760405162461bcd60e51b815260206004820152602760248201527f54686520626f72726f7765722063616e20616c7265616479206265206c69717560448201526634b230ba32b21760c91b606482015260840161013f565b60405163249bbe9160e01b815260048101859052309063249bbe9190602401602060405180830381865afa158015610bb2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bd69190610fe0565b60608301819052610c345760405162461bcd60e51b815260206004820152602260248201527f54686520616d6f756e7420746f20626f72726f7720697320746f6f20736d616c604482015261361760f11b606482015260840161013f565b606082015160e083015161010084015160208501516040516312737c3360e01b81526001600160a01b038a1660048201526024810189905260448101949094526064840192909252608483015260a482015230906312737c339060c401602060405180830381865afa158015610cae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd29190610fe0565b60a0830181905260c08301511015610d435760405162461bcd60e51b815260206004820152602e60248201527f496e73756666696369656e7420636f6c6c61746572616c20746f20636f76657260448201526d1030903732bb903137b93937bb9760911b606482015260840161013f565b60608201516101c0830151604051630deb1bf960e21b81526001600160a01b038416926337ac6fe492610d7e928a9233928b92600401611133565b60408051808303816000875af1158015610d9c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dc09190611187565b6101208401526101a083015260405163fa93b2a560e01b81526001600160a01b0382169063fa93b2a5906101fe90889033908990600401610f74565b7fff5923912191a1cc1ce52c1e63600d3ff20a63ae0f4211e3199b7ba72a991b5a90565b604051806102000160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160006002811115610ea157610ea16110b7565b8152600060209091015290565b80356001600160a01b0381168114610ec557600080fd5b919050565b600080600060608486031215610edf57600080fd5b610ee884610eae565b9250610ef660208501610eae565b9150604084013590509250925092565b60008060408385031215610f1957600080fd5b610f2283610eae565b946020939093013593505050565b600080600060608486031215610f4557600080fd5b610f4e84610eae565b925060208401359150604084013560038110610f6957600080fd5b809150509250925092565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b0392831681529116602082015260400190565b600080600060608486031215610fc757600080fd5b8351925060208401519150604084015190509250925092565b600060208284031215610ff257600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561102257611022610ff9565b92915050565b6001600160a01b03968716815294909516602085015260408401929092526060830152608082015290151560a082015260c00190565b8181038181111561102257611022610ff9565b6001600160a01b0391909116815260200190565b80518015158114610ec557600080fd5b6000602082840312156110a757600080fd5b6110b082611085565b9392505050565b634e487b7160e01b600052602160045260246000fd5b600080600080600080600080610100898b0312156110ea57600080fd5b885197506020890151965060408901519550606089015194506080890151935060a0890151925060c0890151915061112460e08a01611085565b90509295985092959890939650565b6001600160a01b03868116825285166020820152604081018490526060810183905260a081016003831061117757634e487b7160e01b600052602160045260246000fd5b8260808301529695505050505050565b6000806040838503121561119a57600080fd5b50508051602090910151909290915056fe5468657265206973206e6f7420656e6f756768206c6971756964697479206176a2646970667358221220cb91ea52c2166b34d4ca3f659aba6d0d20ff821f9f6647f84bf6d95b2feee1fd64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}