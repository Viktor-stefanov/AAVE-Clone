{
  "language": "Solidity",
  "sources": {
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"./libraries/LibDiamond.sol\";\nimport \"./interfaces/IDiamond.sol\";\n\ncontract Diamond {\n    struct DiamondArgs {\n        address owner;\n        address init;\n        bytes initCalldata;\n    }\n\n    constructor(\n        IDiamond.FacetCut[] memory _diamondCuts,\n        DiamondArgs memory _args\n    ) {\n        LibDiamond.setContractOwner(_args.owner);\n        LibDiamond.diamondCut(_diamondCuts, _args.init, _args.initCalldata);\n    }\n\n    fallback() external payable {\n        LibDiamond.Storage storage ds = LibDiamond.diamondStorage();\n        address facet = ds.selectorToFacet[msg.sig].facetAddress;\n        require(facet != address(0), \"Function not found.\");\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), facet, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\ninterface IDiamond {\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"./IDiamond.sol\";\n\ninterface IDiamondCut is IDiamond {\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IDiamond.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamonds.standart.diamond.storage\");\n\n    struct Facet {\n        address facetAddress;\n        uint16 selectorIndex;\n    }\n\n    struct Storage {\n        address contractOwner;\n        mapping(bytes4 => Facet) selectorToFacet;\n        bytes4[] selectors;\n        mapping(bytes4 => uint256) selectorToIndex;\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    event DiamondCut(\n        IDiamond.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    function diamondStorage() internal pure returns (Storage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        Storage storage ds = diamondStorage();\n        address prevOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(prevOwner, _newOwner);\n    }\n\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCuts,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (\n            uint256 facetIndex = 0;\n            facetIndex < _diamondCuts.length;\n            facetIndex++\n        ) {\n            bytes4[] memory selectors = _diamondCuts[facetIndex]\n                .functionSelectors;\n            address facetAddress = _diamondCuts[facetIndex].facetAddress;\n            require(selectors.length != 0, \"No function selectors provided.\");\n\n            IDiamondCut.FacetCutAction action = _diamondCuts[facetIndex].action;\n            if (action == IDiamond.FacetCutAction.Add)\n                addFunctions(facetAddress, selectors);\n            else if (action == IDiamond.FacetCutAction.Replace)\n                replaceFunctions(facetAddress, selectors);\n            else if (action == IDiamond.FacetCutAction.Remove)\n                removeFunctions(facetAddress, selectors);\n            else revert(\"Invalid action.\");\n            emit DiamondCut(_diamondCuts, _init, _calldata);\n            initializeDiamondCut(_init, _calldata);\n        }\n    }\n\n    function addFunctions(address _facet, bytes4[] memory _selectors) internal {\n        require(\n            _facet != address(0),\n            \"Can't add functions to facet with address 0.\"\n        );\n        enforceHasContractCode(_facet, \"LibDiamond: Add Facet has no code.\");\n        Storage storage ds = diamondStorage();\n        uint16 selectorCount = uint16(_selectors.length);\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            address oldFacetAddress = ds.selectorToFacet[selector].facetAddress;\n            require(\n                oldFacetAddress == address(0),\n                \"Can't add an already existing function.\"\n            );\n            ds.selectorToFacet[selector] = Facet(_facet, selectorCount);\n            ds.selectors.push(selector);\n            ds.selectorToIndex[selector] = ++selectorCount;\n        }\n    }\n\n    function replaceFunctions(address _facet, bytes4[] memory _selectors)\n        internal\n    {\n        require(\n            _facet != address(0),\n            \"Can't replace functions to facet with address 0.\"\n        );\n        enforceHasContractCode(\n            _facet,\n            \"LibDiamond: Replace facet has no code.\"\n        );\n        Storage storage ds = diamondStorage();\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            address oldFacetAddress = ds.selectorToFacet[selector].facetAddress;\n            require(\n                oldFacetAddress != address(0),\n                \"Can't replace a non existing function.\"\n            );\n            require(oldFacetAddress != address(this), \"Function is immutable.\");\n            /// @dev If we remove this check upgrades from the same contract will be possible.\n            require(\n                oldFacetAddress != _facet,\n                \"Can't replace facet with same facet.\"\n            );\n            ds.selectorToFacet[selector].facetAddress = _facet;\n        }\n    }\n\n    function removeFunctions(address _facet, bytes4[] memory _selectors)\n        internal\n    {\n        require(\n            _facet != address(0),\n            \"Can't remove functions from facet with address 0.\"\n        );\n        enforceHasContractCode(_facet, \"LibDiamond: Remove facet has no code.\");\n        Storage storage ds = diamondStorage();\n        uint16 selectorCount = uint16(_selectors.length);\n        for (uint256 i = 0; i < _selectors.length; i++) {\n            bytes4 selector = _selectors[i];\n            Facet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"No facet to remove.\");\n            require(\n                oldFacet.facetAddress != address(this),\n                \"Can't remove an immutable function.\"\n            );\n            /// @TODO: Decypher the next 6 lines of code\n            if (oldFacet.selectorIndex != --selectorCount) {\n                bytes4 lastSelector = ds.selectors[selectorCount];\n                ds.selectors[oldFacet.selectorIndex] = lastSelector;\n                ds.selectorToFacet[lastSelector].selectorIndex = oldFacet\n                    .selectorIndex;\n            }\n            ds.selectors.pop();\n            delete ds.selectorToFacet[selector];\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) return;\n        enforceHasContractCode(_init, \"LibDiamond: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else revert();\n        }\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"Only contract owner has permission for this action.\"\n        );\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize != 0, _errMessage);\n    }\n\n    function contractOwner() internal view returns (address) {\n        return diamondStorage().contractOwner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}