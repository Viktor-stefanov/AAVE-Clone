{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/lendingpool/DataProvider.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"../libraries/LibFacet.sol\";\nimport \"hardhat/console.sol\";\n\ncontract DataProvider {\n    using WadRayMath for uint256;\n\n    struct GetUserGlobalDataVars {\n        uint256 compoundedLiquidityBalance;\n        uint256 compoundedBorrowBalance;\n        uint256 originationFee;\n        uint256 reserveDecimals;\n        uint256 baseLTV;\n        uint256 liquidationThreshold;\n        uint256 tokenUnit;\n        uint256 poolUnitPrice;\n        uint256 liquidityBalanceETH;\n        bool userUsesReserveAsCollateral;\n        bool usageAsCollateralEnabled;\n    }\n\n    /// @dev get user data accross all pools\n    function getUserGlobalData(address _user)\n        public\n        view\n        returns (\n            uint256 totalLiquidityBalanceETH,\n            uint256 totalCollateralBalanceETH,\n            uint256 totalBorrowBalanceETH,\n            uint256 totalFeesETH,\n            uint256 currentLTV,\n            uint256 currentLiquidationThreshold,\n            uint256 healthFactor,\n            bool healthFactorBelowThreshold\n        )\n    {\n        GetUserGlobalDataVars memory vars;\n        LendingPoolCore core = LendingPoolCore(address(this));\n        address[] memory pools = LibFacet.lpcStorage().allPools;\n        for (uint256 poolIdx = 0; poolIdx < pools.length; poolIdx++) {\n            (\n                vars.compoundedLiquidityBalance,\n                vars.compoundedBorrowBalance,\n                vars.originationFee,\n                vars.userUsesReserveAsCollateral\n            ) = core.getUserBasicPoolData(pools[poolIdx], _user);\n\n            if (\n                vars.compoundedBorrowBalance == 0 &&\n                vars.compoundedLiquidityBalance == 0\n            ) continue;\n\n            (\n                vars.reserveDecimals,\n                vars.baseLTV,\n                vars.liquidationThreshold,\n                vars.usageAsCollateralEnabled\n            ) = core.getPoolConfiguration(pools[poolIdx]);\n\n            vars.tokenUnit = 10**vars.reserveDecimals;\n            vars.poolUnitPrice = LibFacet.getPriceFeed().getAssetPrice(\n                pools[poolIdx]\n            );\n\n            if (vars.compoundedLiquidityBalance > 0) {\n                vars.liquidityBalanceETH =\n                    (vars.poolUnitPrice * vars.compoundedLiquidityBalance) /\n                    vars.tokenUnit;\n                /// @dev totalLiquidityBalanceETH is the equivalent asset in US dollars. So 0.5 compoundedLiquidityBalance will yield 750 totalLiquidtiyBalacneETH if price for 1 ETH = 1500\n                totalLiquidityBalanceETH += vars.liquidityBalanceETH;\n\n                if (\n                    vars.usageAsCollateralEnabled &&\n                    vars.userUsesReserveAsCollateral\n                ) {\n                    totalCollateralBalanceETH += vars.liquidityBalanceETH;\n                    currentLTV += vars.liquidityBalanceETH * vars.baseLTV;\n                    currentLiquidationThreshold +=\n                        vars.liquidityBalanceETH *\n                        vars.liquidationThreshold;\n                }\n            }\n\n            if (vars.compoundedBorrowBalance > 0) {\n                totalBorrowBalanceETH +=\n                    (vars.poolUnitPrice * vars.compoundedBorrowBalance) /\n                    vars.tokenUnit;\n                totalFeesETH +=\n                    (vars.originationFee * vars.poolUnitPrice) /\n                    vars.tokenUnit;\n            }\n        }\n\n        /// TODO: aren't the currentLTV and currentLiquidationThreshold always equal to baseLTV and liquidationThreshold?\n        currentLTV = totalCollateralBalanceETH > 0\n            ? currentLTV / totalCollateralBalanceETH\n            : 0;\n        currentLiquidationThreshold = totalCollateralBalanceETH > 0\n            ? currentLiquidationThreshold / totalCollateralBalanceETH\n            : 0;\n        healthFactor = calculateHealthFactorFromBalances(\n            totalCollateralBalanceETH,\n            totalBorrowBalanceETH,\n            totalFeesETH,\n            currentLiquidationThreshold\n        );\n        healthFactorBelowThreshold = healthFactor < 1e18;\n    }\n\n    function getUserPoolData(address _pool, address _user)\n        public\n        view\n        returns (\n            uint256 currentBorrowBalance,\n            uint256 principalBorrowBalance,\n            uint256 liquidityRate,\n            uint256 originationFee,\n            uint256 variableBorrowIndex,\n            uint256 lastUpdatedTimestamp,\n            LibFacet.InterestRateMode borrowRateMode,\n            bool usageAsCollateralEnabled\n        )\n    {\n        LendingPoolCore core = LendingPoolCore(address(this));\n        (principalBorrowBalance, currentBorrowBalance, ) = core\n            .getUserBorrowBalances(_pool, _user);\n        borrowRateMode = core.getUserCurrentBorrowRateMode(_pool, _user);\n        liquidityRate = core.getPoolLiquidityRate(_pool);\n        originationFee = core.getUserOriginationFee(_pool, _user);\n        variableBorrowIndex = core.getUserVariableBorrowIndex(_pool, _user);\n        lastUpdatedTimestamp = core.getUserLastUpdatedTimestamp(_pool, _user);\n        usageAsCollateralEnabled = core.getUserUsePoolAsCollateral(\n            _pool,\n            _user\n        );\n    }\n\n    function getUserRewardShare(address _pool, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 liquidityProvidedByUser = LibFacet\n            .lpcStorage()\n            .pools[_pool]\n            .users[_user]\n            .liquidityProvided;\n        if (liquidityProvidedByUser == 0) return 0;\n\n        uint256 totalLiquidityProvided = 0;\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        for (uint256 userIdx = 0; userIdx < pool.allUsers.length; userIdx++)\n            totalLiquidityProvided += pool\n                .users[pool.allUsers[userIdx]]\n                .liquidityProvided;\n\n        return liquidityProvidedByUser.wadDiv(totalLiquidityProvided);\n    }\n\n    function getAllActivePools() external view returns (address[] memory) {\n        address[] memory allPools = LibFacet.lpcStorage().allPools;\n        address[] memory activePools = new address[](allPools.length);\n        uint256 activePoolIndex = 0;\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (LibFacet.lpcStorage().pools[allPools[i]].isActive)\n                activePools[activePoolIndex++] = allPools[i];\n        }\n\n        return activePools;\n    }\n\n    function getAllActivePoolAssetNames()\n        external\n        view\n        returns (string[] memory)\n    {\n        address[] memory allPools = LibFacet.lpcStorage().allPools;\n        string[] memory activePools = new string[](allPools.length);\n        uint256 activePoolIndex = 0;\n        for (uint256 i = 0; i < allPools.length; i++) {\n            if (LibFacet.lpcStorage().pools[allPools[i]].isActive)\n                activePools[activePoolIndex++] = LibFacet\n                    .lpcStorage()\n                    .pools[allPools[i]]\n                    .asset;\n        }\n\n        return activePools;\n    }\n\n    function getPoolDisplayData(address _pool)\n        external\n        view\n        returns (\n            string memory asset,\n            uint256 loanToValue,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 depositedLiquidity,\n            uint256 borrowedLiquidity,\n            bool isBorrowingEnabled,\n            bool isUsableAsCollateral,\n            bool isActive\n        )\n    {\n        return LendingPoolCore(address(this)).getPoolDisplayInformation(_pool);\n    }\n\n    function getPoolDepositData(address _pool)\n        external\n        view\n        returns (\n            string memory asset,\n            uint256 depositedLiquidity,\n            uint256 borrowedLiquidity,\n            uint256 depositAPY,\n            bool isUsableAsCollateral\n        )\n    {\n        (\n            asset,\n            depositedLiquidity,\n            borrowedLiquidity,\n            isUsableAsCollateral\n        ) = LendingPoolCore(address(this)).getPoolDepositInformation(_pool);\n        depositAPY = LendingPoolCore(address(this)).calculateUserDepositAPY(\n            _pool\n        );\n    }\n\n    function calculateHealthFactorFromBalances(\n        uint256 _totalCollateralBalanceETH,\n        uint256 _totalBorrowBalanceETH,\n        uint256 _totalFeesETH,\n        uint256 _currentLiquidationThreshold\n    ) internal pure returns (uint256) {\n        if (_totalBorrowBalanceETH == 0) return type(uint256).max;\n\n        return\n            ((_totalCollateralBalanceETH * _currentLiquidationThreshold) / 100)\n                .wadDiv(_totalBorrowBalanceETH + _totalFeesETH);\n    }\n\n    function calculateAvailableBorrowsETH(address _user)\n        public\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            uint256 collateralBalanceETH,\n            uint256 borrowBalanceETH,\n            uint256 totalFeesETH,\n            uint256 LTV,\n            ,\n            ,\n\n        ) = getUserGlobalData(_user);\n\n        return\n            calculateAvailableBorrowsETHInternal(\n                collateralBalanceETH,\n                borrowBalanceETH,\n                totalFeesETH,\n                LTV\n            );\n    }\n\n    function calculateAvailableBorrowsETHInternal(\n        uint256 _collateralBalanceETH,\n        uint256 _borrowBalanceETH,\n        uint256 _totalFeesETH,\n        uint256 _LTV\n    ) internal view returns (uint256) {\n        uint256 availableBorrowsETH = (_collateralBalanceETH * _LTV) / 100;\n        if (availableBorrowsETH <= _borrowBalanceETH) return 0;\n\n        availableBorrowsETH -= _borrowBalanceETH + _totalFeesETH;\n\n        uint256 originationFee = FeeProvider(address(this))\n            .calculateLoanOriginationFee(availableBorrowsETH);\n        return availableBorrowsETH - originationFee;\n    }\n\n    function calculateCollateralNeededInETH(\n        address _pool,\n        uint256 _amount,\n        uint256 _fee,\n        uint256 _userCurrentBorrowBalanceETH,\n        uint256 _userCurrentFeesETH,\n        uint256 _userCurrentLTV\n    ) external view returns (uint256 collateralNeededInETH) {\n        PriceFeed pf = LibFacet.getPriceFeed();\n\n        uint256 poolDecimals = LendingPoolCore(address(this)).getPoolDecimals(\n            _pool\n        );\n        uint256 requestedBorrowAmountETH = (pf.getAssetPrice(_pool) *\n            (_amount + _fee)) / 10**poolDecimals;\n        collateralNeededInETH =\n            ((_userCurrentBorrowBalanceETH +\n                _userCurrentFeesETH +\n                requestedBorrowAmountETH) * 100) /\n            _userCurrentLTV;\n    }\n}\n"
    },
    "contracts/lendingpool/FeeProvider.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"../libraries/WadRayMath.sol\";\n\ncontract FeeProvider {\n    using WadRayMath for uint256;\n\n    uint256 internal constant originationFeePercentage = 0.0025 * 1e18;\n\n    function calculateLoanOriginationFee(uint256 _amount)\n        external\n        pure\n        returns (uint256)\n    {\n        return _amount.wadMul(originationFeePercentage);\n    }\n}\n"
    },
    "contracts/lendingpool/LendingPool.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/LibFacet.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LendingPool {\n    using WadRayMath for uint256;\n\n    function deposit(address _pool, uint256 _amount) external payable {\n        require(\n            _pool == LibFacet.facetStorage().ethAddress\n                ? msg.sender.balance >= _amount\n                : ERC20(_pool).balanceOf(msg.sender) >= _amount,\n            \"Insufficient token balance.\"\n        );\n\n        LendingPoolCore core = LendingPoolCore(address(this));\n\n        core.updateStateOnDeposit(_pool, msg.sender, _amount);\n\n        core.transferToPool(_pool, msg.sender, _amount);\n    }\n\n    function redeem(\n        address _pool,\n        address _user,\n        uint256 _amount\n    ) external {\n        LendingPoolCore core = LendingPoolCore(address(this));\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        require(\n            core.getPoolAvailableLiquidity(_pool) >= _amount,\n            \"There is not enough liquidity available to redeem.\"\n        );\n        require(\n            _amount <= getUserMaxRedeemAmount(_pool, _user),\n            \"User cannot redeem more than the accumulated interest.\"\n        );\n        core.updateStateOnRedeem(\n            _pool,\n            _user,\n            _amount,\n            _amount == pool.users[_user].liquidityProvided\n        );\n        core.transferToUser(_pool, _user, _amount);\n    }\n\n    struct BorrowLocalVars {\n        uint256 principalBorrowBalance;\n        uint256 currentLTV;\n        uint256 currentLiquidationThreshold;\n        uint256 borrowFee;\n        uint256 requestedBorrowAmountETH;\n        uint256 amountOfCollateralNeededETH;\n        uint256 userCollateralBalanceETH;\n        uint256 userBorrowBalanceETH;\n        uint256 userTotalFeesETH;\n        uint256 borrowBalanceIncrease;\n        uint256 currentReserveStableRate;\n        uint256 availableLiquidity;\n        uint256 reserveDecimals;\n        uint256 finalUserBorrowRate;\n        LibFacet.InterestRateMode rateMode;\n        bool healthFactorBelowThreshold;\n    }\n\n    function borrow(\n        address _pool,\n        uint256 _amount,\n        LibFacet.InterestRateMode _rateMode\n    ) external {\n        BorrowLocalVars memory vars;\n        LendingPoolCore core = LendingPoolCore(address(this));\n        require(\n            core.isPoolBorrowingEnabled(_pool),\n            \"Pool is not enabled for borrowing.\"\n        );\n        require(\n            _rateMode == LibFacet.InterestRateMode.VARIABLE ||\n                _rateMode == LibFacet.InterestRateMode.STABLE,\n            \"Invalid interest rate mode selected\"\n        );\n        require(\n            core.getPoolAvailableLiquidity(_pool) >= _amount,\n            \"There is not enough liquidity available in the pool.\"\n        );\n\n        (\n            ,\n            vars.userCollateralBalanceETH,\n            vars.userBorrowBalanceETH,\n            vars.userTotalFeesETH,\n            vars.currentLTV,\n            vars.currentLiquidationThreshold,\n            ,\n            vars.healthFactorBelowThreshold\n        ) = DataProvider(address(this)).getUserGlobalData(msg.sender);\n\n        require(\n            vars.userCollateralBalanceETH > 0,\n            \"The collateral balance is 0.\"\n        );\n        require(\n            !vars.healthFactorBelowThreshold,\n            \"The borrower can already be liquidated.\"\n        );\n\n        vars.borrowFee = FeeProvider(address(this)).calculateLoanOriginationFee(\n            _amount\n        );\n\n        require(vars.borrowFee > 0, \"The amount to borrow is too small.\");\n\n        vars.amountOfCollateralNeededETH = DataProvider(address(this))\n            .calculateCollateralNeededInETH(\n                _pool,\n                _amount,\n                vars.borrowFee,\n                vars.userBorrowBalanceETH,\n                vars.userTotalFeesETH,\n                vars.currentLTV\n            );\n\n        require(\n            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\n            \"Insufficient collateral to cover a new borrow.\"\n        );\n\n        /// TODO: add stable rate checks\n        (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core\n            .updateStateOnBorrow(\n                _pool,\n                msg.sender,\n                _amount,\n                vars.borrowFee,\n                vars.rateMode\n            );\n\n        core.transferToUser(_pool, msg.sender, _amount);\n    }\n\n    struct RepayLocalVars {\n        uint256 principalBorrowBalance;\n        uint256 compoundedBorrowBalance;\n        uint256 borrowBalanceIncrease;\n        bool isETH;\n        uint256 paybackAmount;\n        uint256 paybackAmountMinusFee;\n        uint256 currentStableRate;\n        uint256 originationFee;\n    }\n\n    function repay(address _pool, uint256 _amount) external payable {\n        LendingPoolCore core = LendingPoolCore(address(this));\n        RepayLocalVars memory vars;\n\n        (\n            vars.principalBorrowBalance,\n            vars.compoundedBorrowBalance,\n            vars.borrowBalanceIncrease\n        ) = core.getUserBorrowBalances(_pool, msg.sender);\n\n        vars.originationFee = core.getUserOriginationFee(_pool, msg.sender);\n        vars.isETH = LibFacet.facetStorage().ethAddress == _pool;\n\n        require(\n            vars.compoundedBorrowBalance > 0,\n            \"The user does not have any borrow pending.\"\n        );\n\n        /// @note default behavior is to repay the full loan\n        vars.paybackAmount = vars.compoundedBorrowBalance + vars.originationFee;\n        if (_amount < vars.paybackAmount) vars.paybackAmount = _amount;\n\n        require(\n            !vars.isETH || msg.value >= vars.paybackAmount,\n            \"Insufficient msg.value send for the repayment.\"\n        );\n\n        if (vars.paybackAmount <= vars.originationFee) {\n            core.updateStateOnRepay(\n                _pool,\n                msg.sender,\n                0,\n                vars.paybackAmount,\n                vars.borrowBalanceIncrease,\n                false\n            );\n            core.transferToFeeCollector{\n                value: vars.isETH ? vars.paybackAmount : 0\n            }(_pool, msg.sender, vars.paybackAmount);\n            return;\n        }\n\n        vars.paybackAmountMinusFee = vars.paybackAmount - vars.originationFee;\n\n        core.updateStateOnRepay(\n            _pool,\n            msg.sender,\n            vars.paybackAmountMinusFee,\n            vars.originationFee,\n            vars.borrowBalanceIncrease,\n            vars.compoundedBorrowBalance == vars.paybackAmountMinusFee\n        );\n\n        if (vars.originationFee > 0) {\n            core.transferToFeeCollector{\n                value: vars.isETH ? vars.originationFee : 0\n            }(_pool, msg.sender, vars.originationFee);\n        }\n\n        core.transferToPool(_pool, msg.sender, vars.paybackAmountMinusFee);\n    }\n\n    function setUserUsePoolAsCollateral(address _pool, bool _useAsCollateral)\n        external\n    {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        require(\n            pool.users[msg.sender].liquidityProvided > 0,\n            \"User does not have any liquidity deposited.\"\n        );\n        require(\n            !pool.users[msg.sender].useAsCollateral,\n            \"User deposit is already used as collateral.\"\n        );\n        LendingPoolCore(address(this)).setUserUsePoolAsCollateralInternal(\n            _pool,\n            msg.sender,\n            _useAsCollateral\n        );\n    }\n\n    // Q: why do we take the origination fee from the compounded balance and not the principal amount?\n    // A: because that is an implementation detail and the original AAVE protocol leaves this part out to the government module\n    function calculateUserAmountToRepay(address _pool, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        (, uint256 compoundedBorrowBalance, ) = LendingPoolCore(address(this))\n            .getUserBorrowBalances(_pool, _user);\n        uint256 originationFee = FeeProvider(address(this))\n            .calculateLoanOriginationFee(compoundedBorrowBalance);\n\n        return compoundedBorrowBalance + originationFee;\n    }\n\n    function liquidationCall(address _pool, address _userToLiquidate)\n        external\n        payable\n    {}\n\n    function getUserMaxRedeemAmount(address _pool, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            LendingPoolCore(address(this)).getUserCumulatedRewards(\n                _pool,\n                _user,\n                LibFacet.lpcStorage().pools[_pool].rewardsLiquidity\n            ) +\n            LibFacet.lpcStorage().pools[_pool].users[_user].liquidityProvided;\n    }\n}\n"
    },
    "contracts/lendingpool/LendingPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"../libraries/LibFacet.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"hardhat/console.sol\";\n\ncontract LendingPoolConfigurator {\n    using WadRayMath for uint256;\n\n    function init(\n        address _ethAddress,\n        address _lpcAddress,\n        address _pfAddress,\n        address _dpAddress\n    ) external {\n        console.log(\"initialized global state\");\n        LibFacet.facetStorage().ethAddress = _ethAddress;\n        LibFacet.facetStorage().priceFeedAddress = _pfAddress;\n        LibFacet.facetStorage().dataProviderAddress = _dpAddress;\n        LibFacet.facetStorage().lpcAddress = _lpcAddress;\n    }\n\n    function initPool(\n        address _pool,\n        string memory _asset,\n        uint256 _decimals,\n        LibFacet.TokenVolatility _volatility\n    ) external {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        pool.asset = _asset;\n        pool.decimals = _decimals;\n        pool.cumulatedLiquidityIndex = WadRayMath.RAY;\n        pool.cumulatedVariableBorrowIndex = WadRayMath.RAY;\n        pool.isActive = true;\n        pool.isBorrowingEnabled = true;\n        pool.isUsableAsCollateral = true;\n        pool.lastUpdatedTimestamp = block.timestamp;\n        if (_volatility == LibFacet.TokenVolatility.LOW) {\n            pool.rates.interestRateSlopeAbove = 60 * WadRayMath.RAY;\n            pool.rates.interestRateSlopeBelow = 4 * WadRayMath.RAY;\n            pool.rates.baseVariableBorrowRate = 0;\n            pool.rates.targetUtilisationRate = 90 * WadRayMath.RAY;\n            pool.liquidationThreshold = 90; /// TODO: consider if this is a good default value\n            pool.liquidationBonus = 10;\n            pool.loanToValue = 85;\n            pool.baseLTV = 85;\n        } else if (_volatility == LibFacet.TokenVolatility.HIGH) {\n            pool.rates.interestRateSlopeAbove = (100 * WadRayMath.RAY) / 100;\n            pool.rates.interestRateSlopeBelow = (8 * WadRayMath.RAY) / 100;\n            pool.rates.baseVariableBorrowRate = 0;\n            pool.rates.targetUtilisationRate = (65 * WadRayMath.RAY) / 100;\n            pool.liquidationThreshold = 70;\n            pool.liquidationBonus = 5;\n            pool.loanToValue = 65;\n            pool.baseLTV = 65;\n        }\n        LibFacet.lpcStorage().allPools.push(_pool);\n    }\n}\n"
    },
    "contracts/lendingpool/LendingPoolCore.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"./DataProvider.sol\";\nimport \"../libraries/LibFacet.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../mocks/EthMock.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"hardhat/console.sol\";\n\n// @TODO rename _balanceIncrease to something like \"accumulatedInterest\"\ncontract LendingPoolCore {\n    using WadRayMath for uint256;\n\n    function getEthValue(address _token, uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 loanToValue = LibFacet.lpcStorage().pools[_token].loanToValue;\n        return ((_amount * loanToValue) / 100);\n    }\n\n    function updateStateOnDeposit(\n        address _pool,\n        address _user,\n        uint256 _amount\n    ) public {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        updateCumulativeIndexes(pool);\n        updatePoolInterestRates(pool, _amount, 0);\n        bool isFirstDeposit = pool.users[_user].liquidityProvided == 0;\n        pool.providedLiquidity += _amount;\n        pool.users[_user].liquidityProvided += _amount;\n        if (isFirstDeposit) {\n            pool.allUsers.push(_user);\n            setUserUsePoolAsCollateralInternal(_pool, _user, true);\n            initializeUserData(pool.users[_user]);\n        }\n    }\n\n    function updateStateOnRedeem(\n        address _pool,\n        address _user,\n        uint256 _amount,\n        bool _userRedeemedEverything\n    ) public {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        updateCumulativeIndexes(pool);\n\n        uint256 liquidityProvided = pool.users[_user].liquidityProvided;\n        if (_amount > liquidityProvided) {\n            updatePoolInterestRates(pool, 0, liquidityProvided);\n            pool.users[_user].liquidityProvided = 0;\n            pool.providedLiquidity -= liquidityProvided;\n            pool.rewardsLiquidity -= (_amount - liquidityProvided);\n        } else {\n            updatePoolInterestRates(pool, 0, _amount);\n            pool.providedLiquidity -= _amount;\n            pool.users[_user].liquidityProvided -= _amount;\n        }\n\n        if (_userRedeemedEverything) {\n            setUserUsePoolAsCollateralInternal(_pool, _user, false);\n            pool.users[_user].rates.variableBorrowRate = 0;\n            pool.users[_user].rates.stableBorrowRate = 0;\n            pool.users[_user].rates.stableBorrowRate = 0;\n            pool.users[_user].rates.cumulatedVariableBorrowIndex =\n                1 *\n                WadRayMath.RAY;\n        }\n    }\n\n    function updateStateOnBorrow(\n        address _pool,\n        address _user,\n        uint256 _amount,\n        uint256 _borrowFee,\n        LibFacet.InterestRateMode _rateMode\n    ) public returns (uint256, uint256) {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        LibFacet.UserPoolData storage user = pool.users[_user];\n        (\n            uint256 principalBorrowBalance,\n            ,\n            uint256 balanceIncrease\n        ) = getUserBorrowBalances(_pool, _user);\n\n        updatePoolStateOnBorrow(\n            pool,\n            _user,\n            principalBorrowBalance,\n            balanceIncrease,\n            _amount,\n            _rateMode\n        );\n\n        updateUserStateOnBorrow(\n            pool,\n            user,\n            _amount,\n            balanceIncrease,\n            _borrowFee,\n            _rateMode\n        );\n\n        updatePoolInterestRates(pool, 0, _amount);\n\n        return (getUserCurrentBorrowRate(pool, _user), balanceIncrease);\n    }\n\n    function updateStateOnRepay(\n        address _pool,\n        address _user,\n        uint256 _paybackAmountMinusFee,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) external {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n\n        updatePoolStateOnRepay(\n            pool,\n            _pool,\n            _user,\n            _paybackAmountMinusFee,\n            _balanceIncrease\n        );\n        updateUserStateOnRepay(\n            pool,\n            _user,\n            _paybackAmountMinusFee,\n            _originationFeeRepaid,\n            _balanceIncrease,\n            _repaidWholeLoan\n        );\n\n        updatePoolInterestRates(pool, _paybackAmountMinusFee, 0);\n    }\n\n    function updatePoolStateOnRepay(\n        LibFacet.Pool storage _pool,\n        address _poolAddress,\n        address _user,\n        uint256 _paybackAmountMinusFee,\n        uint256 _balanceIncrease\n    ) internal {\n        updateCumulativeIndexes(_pool);\n        _pool.rewardsLiquidity += _balanceIncrease;\n        _pool.borrowedLiquidity -= _paybackAmountMinusFee - _balanceIncrease;\n\n        LibFacet.InterestRateMode borrowMode = getUserCurrentBorrowRateMode(\n            _poolAddress,\n            _user\n        );\n        if (borrowMode == LibFacet.InterestRateMode.VARIABLE) {\n            increaseTotalVariableBorrows(_pool, _balanceIncrease);\n            decreaseTotalVariableBorrows(_pool, _paybackAmountMinusFee);\n        } else {}\n    }\n\n    function updateUserStateOnRepay(\n        LibFacet.Pool storage _pool,\n        address _user,\n        uint256 _paybackAmountMinusFee,\n        uint256 _originationFeeRepaid,\n        uint256 _balanceIncrease,\n        bool _repaidWholeLoan\n    ) internal {\n        LibFacet.UserPoolData storage user = _pool.users[_user];\n        user.principalBorrowBalance -=\n            _paybackAmountMinusFee -\n            _balanceIncrease;\n        user.cumulatedVariableBorrowIndex = _pool.cumulatedVariableBorrowIndex;\n        if (_repaidWholeLoan) {\n            user.rates.stableBorrowRate = 0;\n            user.rates.variableBorrowRate = 0;\n        }\n        user.originationFee = user.originationFee - _originationFeeRepaid;\n        user.lastUpdatedTimestamp = block.timestamp;\n    }\n\n    function updatePoolStateOnBorrow(\n        LibFacet.Pool storage _pool,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        LibFacet.InterestRateMode _rateMode\n    ) internal {\n        updateCumulativeIndexes(_pool);\n        updatePoolTotalBorrows(\n            _pool,\n            _user,\n            _principalBorrowBalance,\n            _balanceIncrease,\n            _amountBorrowed,\n            _rateMode\n        );\n        _pool.borrowedLiquidity += _amountBorrowed;\n    }\n\n    // TODO: ADD previous values of indexes to the Pool and UserPoolData structs.\n    function updateUserStateOnBorrow(\n        LibFacet.Pool storage _pool,\n        LibFacet.UserPoolData storage _user,\n        uint256 _amountBorrowed,\n        uint256 _balanceIncrease,\n        uint256 _fee,\n        LibFacet.InterestRateMode _rateMode\n    ) internal {\n        if (_rateMode == LibFacet.InterestRateMode.STABLE) {} else if (\n            _rateMode == LibFacet.InterestRateMode.VARIABLE\n        ) {\n            _user.rates.stableBorrowRate = 0;\n            _user.cumulatedVariableBorrowIndex = _pool\n                .cumulatedVariableBorrowIndex;\n        } else {\n            revert(\"Invalid borrow mode.\");\n        }\n\n        _user.principalBorrowBalance += _balanceIncrease + _amountBorrowed;\n        _user.originationFee = _user.originationFee + _fee;\n        _user.lastUpdatedTimestamp = block.timestamp;\n    }\n\n    function updatePoolTotalBorrows(\n        LibFacet.Pool storage _pool,\n        address _user,\n        uint256 _principalBorrowBalance,\n        uint256 _balanceIncrease,\n        uint256 _amountBorrowed,\n        LibFacet.InterestRateMode _newRateMode\n    ) internal {\n        LibFacet.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n                _pool.users[_user]\n            );\n        if (previousRateMode == LibFacet.InterestRateMode.STABLE) {} else if (\n            previousRateMode == LibFacet.InterestRateMode.VARIABLE\n        ) {\n            decreaseTotalVariableBorrows(_pool, _principalBorrowBalance);\n        }\n\n        uint256 newPrincipalAmount = _principalBorrowBalance +\n            _amountBorrowed +\n            _balanceIncrease;\n        if (_newRateMode == LibFacet.InterestRateMode.STABLE) {} else if (\n            _newRateMode == LibFacet.InterestRateMode.VARIABLE\n        ) {\n            increaseTotalVariableBorrows(_pool, newPrincipalAmount);\n        } else {\n            revert(\"Invalid new borrow rate mode.\");\n        }\n    }\n\n    function decreaseTotalVariableBorrows(\n        LibFacet.Pool storage _pool,\n        uint256 _amount\n    ) internal {\n        require(\n            _pool.variableBorrowLiquidity >= _amount,\n            \"The amount that is being subtracted from the variable borrows is incorrect.\"\n        );\n        _pool.variableBorrowLiquidity -= _amount;\n    }\n\n    function increaseTotalVariableBorrows(\n        LibFacet.Pool storage _pool,\n        uint256 _amount\n    ) internal {\n        _pool.variableBorrowLiquidity += _amount;\n    }\n\n    function getPoolLiquidityRate(address _pool) public view returns (uint256) {\n        return LibFacet.lpcStorage().pools[_pool].rates.currentLiquidityRate;\n    }\n\n    function getUserCurrentBorrowRateMode(LibFacet.UserPoolData memory _user)\n        internal\n        pure\n        returns (LibFacet.InterestRateMode)\n    {\n        if (_user.principalBorrowBalance == 0)\n            return LibFacet.InterestRateMode.NONE;\n\n        return\n            _user.rates.stableBorrowRate > 0\n                ? LibFacet.InterestRateMode.STABLE\n                : LibFacet.InterestRateMode.VARIABLE;\n    }\n\n    function updateCumulativeIndexes(LibFacet.Pool storage _pool) internal {\n        if (_pool.borrowedLiquidity > 0) {\n            _pool.cumulatedLiquidityIndex = calculateLinearInterest(\n                _pool.rates.currentLiquidityRate,\n                _pool.lastUpdatedTimestamp\n            ).rayMul(_pool.cumulatedLiquidityIndex);\n            _pool.cumulatedVariableBorrowIndex = calculateCompoundedInterest(\n                _pool.rates.variableBorrowRate,\n                LibFacet.SECONDS_IN_A_YEAR,\n                block.timestamp,\n                _pool.lastUpdatedTimestamp\n            ).rayMul(_pool.cumulatedVariableBorrowIndex);\n        }\n    }\n\n    function updatePoolInterestRates(\n        LibFacet.Pool storage _pool,\n        uint256 _liquidityAdded,\n        uint256 _liquidityTaken\n    ) internal {\n        (\n            _pool.rates.variableBorrowRate,\n            _pool.rates.currentLiquidityRate\n        ) = calculateInterestRates(\n            _pool.providedLiquidity + _liquidityAdded - _liquidityTaken,\n            _pool.variableBorrowLiquidity,\n            _pool.rates.interestRateSlopeBelow,\n            _pool.rates.interestRateSlopeAbove,\n            _pool.rates.baseVariableBorrowRate,\n            _pool.rates.targetUtilisationRate\n        );\n        _pool.rates.overallBorrowRate = _pool.rates.variableBorrowRate;\n        _pool.lastUpdatedTimestamp = block.timestamp;\n    }\n\n    function calculateInterestRates(\n        uint256 _totalLiquidity,\n        uint256 _totalVariableBorrows,\n        uint256 _variableRateSlope1,\n        uint256 _variableRateSlope2,\n        uint256 _baseVariableBorrowRate,\n        uint256 _optimalUtilizationRate\n    )\n        internal\n        pure\n        returns (\n            uint256 currentVariableBorrowRate,\n            uint256 currentLiquidityRate\n        )\n    {\n        uint256 totalBorrows = _totalVariableBorrows; /// @dev + totalStableBorrows\n        uint256 utilizationRate = (_totalLiquidity == 0 && totalBorrows == 0)\n            ? 0\n            : totalBorrows.rayDiv(_totalLiquidity);\n\n        if (utilizationRate > _optimalUtilizationRate) {\n            uint256 excessUtilizationRateRatio = (utilizationRate -\n                _optimalUtilizationRate).rayDiv(\n                    WadRayMath.RAY - _optimalUtilizationRate\n                );\n            currentVariableBorrowRate =\n                _baseVariableBorrowRate +\n                _variableRateSlope1 +\n                (_variableRateSlope2.rayMul(excessUtilizationRateRatio));\n        } else {\n            currentVariableBorrowRate =\n                _baseVariableBorrowRate +\n                (\n                    utilizationRate.rayDiv(_optimalUtilizationRate).rayMul(\n                        _variableRateSlope1\n                    )\n                );\n        }\n        uint256 overallBorrowRate = calculateOverallBorrowRate(\n            _totalVariableBorrows,\n            currentVariableBorrowRate\n        );\n        currentLiquidityRate = overallBorrowRate.rayMul(utilizationRate);\n    }\n\n    function calculateOverallBorrowRate(\n        uint256 _totalVariableBorrows,\n        uint256 _currentVariableBorrowRate\n    ) internal pure returns (uint256) {\n        uint256 totalBorrows = _totalVariableBorrows; /// TODO: + _totalStableBorrows\n        if (totalBorrows == 0) return 0;\n\n        uint256 weightedVariableRate = _totalVariableBorrows.wadToRay().rayMul(\n            _currentVariableBorrowRate\n        );\n\n        return weightedVariableRate.rayDiv(totalBorrows.wadToRay());\n    }\n\n    function getUserBorrowBalances(address _pool, address _user)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        LibFacet.UserPoolData storage user = pool.users[_user];\n        if (user.principalBorrowBalance == 0) return (0, 0, 0);\n\n        uint256 compoundedBalance = getCompoundedBorrowBalance(user, pool);\n        return (\n            user.principalBorrowBalance,\n            compoundedBalance,\n            compoundedBalance - user.principalBorrowBalance\n        );\n    }\n\n    function getUserOriginationFee(address _pool, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        return LibFacet.lpcStorage().pools[_pool].users[_user].originationFee;\n    }\n\n    /// TODO: internal\n    /// @dev calculates interest using compounded interest rate formula\n    function calculateCompoundedInterest(\n        uint256 _variableBorrowRate,\n        uint256 _secondsInAYear,\n        uint256 _timestamp,\n        uint256 _lastUpdatedTimestamp\n    ) public pure returns (uint256) {\n        uint256 ratePerSecond = _variableBorrowRate / _secondsInAYear;\n\n        return\n            (WadRayMath.RAY + ratePerSecond).rayPow(\n                _timestamp - _lastUpdatedTimestamp\n            );\n    }\n\n    /// @dev calculates interest using linear interest rate formula\n    function calculateLinearInterest(\n        uint256 _currentLiquidityRate,\n        uint256 _lastUpdatedTimestamp\n    ) internal view returns (uint256) {\n        uint256 timeDelta = calculateTimeDelta(\n            block.timestamp,\n            _lastUpdatedTimestamp,\n            LibFacet.SECONDS_IN_A_YEAR\n        );\n        return _currentLiquidityRate.rayMul(timeDelta) + WadRayMath.RAY;\n    }\n\n    function calculateTimeDelta(\n        uint256 _timestamp,\n        uint256 _lastUpdatedTimestamp,\n        uint256 _secondsInAYear\n    ) internal pure returns (uint256) {\n        return (_timestamp - _lastUpdatedTimestamp) / _secondsInAYear;\n    }\n\n    function getCompoundedBorrowBalance(\n        LibFacet.UserPoolData storage _user,\n        LibFacet.Pool storage _pool\n    ) internal view returns (uint256) {\n        if (_user.principalBorrowBalance == 0) return 0;\n\n        uint256 principalBorrowBalance = _user\n            .principalBorrowBalance\n            .wadToRay();\n        uint256 compoundedBalance = 0;\n        uint256 cumulatedInterest = 0;\n\n        if (_user.rates.stableBorrowRate > 0) {} else {\n            cumulatedInterest = calculateCompoundedInterest(\n                _pool.rates.variableBorrowRate,\n                LibFacet.SECONDS_IN_A_YEAR,\n                block.timestamp,\n                _pool.lastUpdatedTimestamp\n            ).rayMul(_pool.cumulatedVariableBorrowIndex).rayDiv(\n                    _user.cumulatedVariableBorrowIndex\n                );\n        }\n\n        compoundedBalance = principalBorrowBalance\n            .rayMul(cumulatedInterest)\n            .rayToWad();\n\n        if (compoundedBalance == _user.principalBorrowBalance)\n            if (_user.lastUpdatedTimestamp != block.timestamp)\n                return _user.principalBorrowBalance + 1 wei;\n\n        return compoundedBalance;\n    }\n\n    function getUserVariableBorrowIndex(address _pool, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            LibFacet\n                .lpcStorage()\n                .pools[_pool]\n                .users[_user]\n                .rates\n                .variableBorrowRate;\n    }\n\n    function getUserUsePoolAsCollateral(address _pool, address _user)\n        public\n        view\n        returns (bool)\n    {\n        return LibFacet.lpcStorage().pools[_pool].users[_user].useAsCollateral;\n    }\n\n    function getUserCurrentBorrowRate(\n        LibFacet.Pool storage _pool,\n        address _user\n    ) internal view returns (uint256) {\n        LibFacet.InterestRateMode rateMode = getUserCurrentBorrowRateMode(\n            _pool.users[_user]\n        );\n\n        if (rateMode == LibFacet.InterestRateMode.NONE) return 0;\n\n        return\n            rateMode == LibFacet.InterestRateMode.STABLE\n                ? 0\n                : _pool.rates.variableBorrowRate;\n    }\n\n    function getUserCurrentBorrowRateMode(address _pool, address _user)\n        public\n        view\n        returns (LibFacet.InterestRateMode)\n    {\n        return LibFacet.lpcStorage().pools[_pool].users[_user].rates.rateMode;\n    }\n\n    function getUserLastUpdatedTimestamp(address _pool, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            LibFacet\n                .lpcStorage()\n                .pools[_pool]\n                .users[_user]\n                .lastUpdatedTimestamp;\n    }\n\n    function getUserBasicPoolData(address _pool, address _user)\n        public\n        view\n        returns (\n            uint256 compoundedLiquidityBalance,\n            uint256 compoundedBorrowBalance,\n            uint256 originationFee,\n            bool userUsesPoolAsCollateral\n        )\n    {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        /// Q: How to compound the deposited balance? Don't return just the 'principal' amount.\n        /// A: Store the compounded interest from loans and distribute it amongst the depositors based on their share.\n        uint256 assetBalance = pool.users[_user].liquidityProvided;\n        if (pool.users[_user].principalBorrowBalance == 0)\n            return (assetBalance, 0, 0, pool.users[_user].useAsCollateral);\n\n        return (\n            assetBalance,\n            getCompoundedBorrowBalance(pool.users[_user], pool),\n            pool.users[_user].originationFee,\n            pool.users[_user].useAsCollateral\n        );\n    }\n\n    function getUserCumulatedRewards(\n        address _pool,\n        address _user,\n        uint256 _totalRewards\n    ) public view returns (uint256) {\n        uint256 userShare = DataProvider(address(this)).getUserRewardShare(\n            _pool,\n            _user\n        );\n\n        return (_totalRewards * userShare) / 10**18;\n    }\n\n    function getPoolDepositInformation(address _pool)\n        public\n        view\n        returns (\n            string memory asset,\n            uint256 depositedLiquidity,\n            uint256 borrowedLiquidity,\n            bool isUsableAsCollateral\n        )\n    {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        return (\n            pool.asset,\n            pool.providedLiquidity,\n            pool.borrowedLiquidity,\n            pool.isUsableAsCollateral\n        );\n    }\n\n    function getPoolDisplayInformation(address _pool)\n        public\n        view\n        returns (\n            string memory,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        )\n    {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        return (\n            pool.asset,\n            pool.loanToValue,\n            pool.liquidationThreshold,\n            pool.liquidationBonus,\n            pool.providedLiquidity,\n            pool.borrowedLiquidity,\n            pool.isBorrowingEnabled,\n            pool.isUsableAsCollateral,\n            pool.isActive\n        );\n    }\n\n    function getPoolConfiguration(address _pool)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        return (\n            pool.decimals,\n            pool.baseLTV,\n            pool.liquidationThreshold,\n            pool.isUsableAsCollateral\n        );\n    }\n\n    function getPoolDecimals(address _pool) public view returns (uint256) {\n        return LibFacet.lpcStorage().pools[_pool].decimals;\n    }\n\n    function getPoolCumulatedRewards(address _pool)\n        public\n        view\n        returns (uint256)\n    {\n        return LibFacet.lpcStorage().pools[_pool].rewardsLiquidity;\n    }\n\n    function getPoolAvailableLiquidity(address _pool)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            LibFacet.lpcStorage().pools[_pool].providedLiquidity +\n            LibFacet.lpcStorage().pools[_pool].rewardsLiquidity -\n            LibFacet.lpcStorage().pools[_pool].borrowedLiquidity;\n    }\n\n    function calculateUserDepositAPY(address _pool)\n        public\n        view\n        returns (uint256)\n    {\n        LibFacet.Pool storage pool = LibFacet.lpcStorage().pools[_pool];\n        if (pool.providedLiquidity == 0) return 0;\n\n        uint256 oneYearAhead = pool.lastUpdatedTimestamp + 365 days;\n        uint256 cumulatedInterest = LendingPoolCore(address(this))\n            .calculateCompoundedInterest(\n                pool.rates.variableBorrowRate,\n                LibFacet.SECONDS_IN_A_YEAR,\n                oneYearAhead,\n                pool.lastUpdatedTimestamp\n            )\n            .rayMul(pool.cumulatedVariableBorrowIndex);\n        uint256 compoundedInterest = pool\n            .borrowedLiquidity\n            .wadToRay()\n            .rayMul(cumulatedInterest)\n            .rayToWad();\n        uint256 cumulatedValue = compoundedInterest - pool.borrowedLiquidity;\n\n        return\n            (pool.providedLiquidity + cumulatedValue).wadDiv(\n                pool.providedLiquidity\n            ) - WadRayMath.WAD;\n    }\n\n    function isPoolBorrowingEnabled(address _pool) public view returns (bool) {\n        return LibFacet.lpcStorage().pools[_pool].isBorrowingEnabled;\n    }\n\n    function isPoolUsageAsCollateralEnabled(address _pool)\n        public\n        view\n        returns (bool)\n    {\n        return LibFacet.lpcStorage().pools[_pool].isUsableAsCollateral;\n    }\n\n    function setUserUsePoolAsCollateralInternal(\n        address _pool,\n        address _user,\n        bool _useAsCollateral\n    ) public {\n        LibFacet\n            .lpcStorage()\n            .pools[_pool]\n            .users[_user]\n            .useAsCollateral = _useAsCollateral;\n    }\n\n    function initializeUserData(LibFacet.UserPoolData storage _user) internal {\n        _user.cumulatedVariableBorrowIndex = WadRayMath.RAY;\n        _user.cumulatedVariableBorrowIndex = WadRayMath.RAY;\n    }\n\n    function transferToPool(\n        address _pool,\n        address _user,\n        uint256 _amount\n    ) public payable {\n        if (_pool == LibFacet.facetStorage().ethAddress) {\n            (bool success, ) = _pool.call{value: _amount}(\"\");\n            require(success, \"Error while sending ETH.\");\n        } else {\n            ERC20(_pool).transferFrom(_user, _pool, _amount);\n        }\n    }\n\n    function transferToUser(\n        address _pool,\n        address _user,\n        uint256 _amount\n    ) public {\n        if (_pool == LibFacet.facetStorage().ethAddress) {\n            EthMock(payable(_pool)).transferEthToUser(_user, _amount);\n        } else {\n            ERC20(_pool).transferFrom(_pool, _user, _amount);\n        }\n    }\n\n    function transferToFeeCollector(\n        address _token,\n        address _user,\n        uint256 _amount\n    ) public payable {\n        address feeProvider = LibFacet.facetStorage().feeProviderAddress;\n        if (_token != LibFacet.facetStorage().ethAddress) {\n            require(\n                msg.value == 0,\n                \"User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction\"\n            );\n            ERC20(_token).transferFrom(_user, feeProvider, _amount);\n        } else {\n            require(\n                msg.value >= _amount,\n                \"The amount and the value sent to deposit do not match\"\n            );\n            (bool result, ) = feeProvider.call{value: _amount}(\"\");\n            require(result, \"Transfer of ETH failed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/LibFacet.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"../lendingpool/LendingPoolCore.sol\";\nimport \"../lendingpool/DataProvider.sol\";\nimport \"../lendingpool/FeeProvider.sol\";\nimport \"../mocks/PriceFeed.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary LibFacet {\n    uint256 internal constant SECONDS_IN_A_YEAR = 365 days;\n    uint256 internal constant RATE_MULTIPLIER = 10**8;\n    bytes32 internal constant LENDING_POOL_CORE_STORAGE_POSITION =\n        keccak256(\"diamonds.standart.lending.pool.core.storage\");\n    bytes32 internal constant FACET_STORAGE_POSITION =\n        keccak256(\"diamonds.standart.facet.storage\");\n\n    // user data tied to a specific pool\n    struct UserPoolData {\n        uint256 liquidityProvided;\n        uint256 principalBorrowBalance;\n        uint256 cumulatedVariableBorrowIndex;\n        uint256 lastCumulatedVariableBorrowIndex;\n        uint256 compoundedBorrowBalance;\n        uint256 collateralETHBalance;\n        uint256 liquidationThreshold;\n        uint256 originationFee;\n        uint256 healthFactor;\n        uint256 lastUpdatedTimestamp;\n        bool useAsCollateral;\n        UserInterestRate rates;\n    }\n\n    struct Pool {\n        string asset;\n        uint256 decimals;\n        uint256 providedLiquidity;\n        uint256 borrowedLiquidity;\n        uint256 rewardsLiquidity;\n        uint256 variableBorrowLiquidity;\n        uint256 cumulatedLiquidityIndex; // interest cumulated by the reserve during the time interval Dt\n        uint256 reserveNormalizedIncome; // Ongoing interest cumulated by the reserve\n        uint256 cumulatedVariableBorrowIndex;\n        uint256 baseLTV;\n        uint256 loanToValue;\n        uint256 liquidationThreshold;\n        uint256 liquidationBonus; // represented in percentage\n        uint256 lastUpdatedTimestamp;\n        bool isBorrowingEnabled;\n        bool isUsableAsCollateral;\n        bool isActive;\n        bool isFreezed; // only allow repays and redeems, but not deposits, new borrowings or rate swap.\n        InterestRate rates;\n        address[] allUsers;\n        mapping(address => UserPoolData) users;\n    }\n\n    struct LPCStorage {\n        mapping(address => Pool) pools;\n        address[] allPools;\n    }\n\n    struct FacetStorage {\n        address ethAddress;\n        address lpcAddress;\n        address dataProviderAddress;\n        address priceFeedAddress;\n        address feeProviderAddress;\n    }\n\n    struct InterestRate {\n        InterestRateMode rateMode;\n        uint256 targetUtilisationRate;\n        uint256 interestRateSlopeBelow; // constant representing the scaling of the interest rate vs the utilization.\n        uint256 interestRateSlopeAbove;\n        uint256 baseVariableBorrowRate; // constant for totalBorrows = 0. Expressed in ray\n        uint256 variableBorrowRate;\n        uint256 overallBorrowRate; // (VariableBorrowRate * TotalVariableBorrows) / totalBorrows\n        uint256 currentLiquidityRate; // overallBorrowRate * utilizationRate\n    }\n\n    struct UserInterestRate {\n        InterestRateMode rateMode;\n        uint256 variableBorrowRate;\n        uint256 stableBorrowRate;\n        uint256 cumulatedVariableBorrowIndex;\n    }\n\n    enum TokenVolatility {\n        LOW,\n        HIGH\n    }\n\n    enum InterestRateMode {\n        VARIABLE,\n        STABLE,\n        NONE\n    }\n\n    function lpcStorage() internal pure returns (LPCStorage storage lpcs) {\n        bytes32 position = LENDING_POOL_CORE_STORAGE_POSITION;\n        assembly {\n            lpcs.slot := position\n        }\n    }\n\n    function facetStorage() internal pure returns (FacetStorage storage fs) {\n        bytes32 position = FACET_STORAGE_POSITION;\n        assembly {\n            fs.slot := position\n        }\n    }\n\n    function getDataProvider() internal view returns (DataProvider) {\n        return DataProvider(facetStorage().dataProviderAddress);\n    }\n\n    function getFeeProvider() internal view returns (FeeProvider) {\n        return FeeProvider(facetStorage().feeProviderAddress);\n    }\n\n    function getPriceFeed() internal view returns (PriceFeed) {\n        return PriceFeed(facetStorage().priceFeedAddress);\n    }\n}\n"
    },
    "contracts/libraries/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary WadRayMath {\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant HALF_WAD = 0.5e18;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant HALF_RAY = 0.5e27;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    /**\n     * @dev Multiplies two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a*b, in wad\n     **/\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n        assembly {\n            // Equivalent to require(x == 0 || (x * y) / x == y)\n            if iszero(\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_WAD), WAD)\n        }\n    }\n\n    /**\n     * @dev Divides two wad, rounding half up to the nearest wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @param b Wad\n     * @return c = a/b, in wad\n     **/\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n        assembly {\n            if or(\n                iszero(b),\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, WAD), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @notice Multiplies two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raymul b\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n        assembly {\n            if iszero(\n                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, b), HALF_RAY), RAY)\n        }\n    }\n\n    /**\n     * @notice Divides two ray, rounding half up to the nearest ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @param b Ray\n     * @return c = a raydiv b\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n        assembly {\n            if or(\n                iszero(b),\n                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))\n            ) {\n                revert(0, 0)\n            }\n\n            c := div(add(mul(a, RAY), div(b, 2)), b)\n        }\n    }\n\n    /**\n     * @dev Casts ray down to wad\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Ray\n     * @return b = a converted to wad, rounded half up to the nearest wad\n     **/\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\n        assembly {\n            b := div(a, WAD_RAY_RATIO)\n            let remainder := mod(a, WAD_RAY_RATIO)\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n                b := add(b, 1)\n            }\n        }\n    }\n\n    /**\n     * @dev Converts wad up to ray\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n     * @param a Wad\n     * @return b = a converted in ray\n     **/\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\n        // to avoid overflow, b/WAD_RAY_RATIO == a\n        assembly {\n            b := mul(a, WAD_RAY_RATIO)\n\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n        for (n /= 2; n != 0; n /= 2) {\n            x = rayMul(x, x);\n\n            if (n % 2 != 0) {\n                z = rayMul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/EthMock.sol": {
      "content": "pragma solidity 0.8.17;\n\nimport \"../libraries/LibFacet.sol\";\n\ncontract EthMock {\n    function transferEthToUser(address _user, uint256 _amount) public payable {\n        (bool success, ) = _user.call{value: _amount}(\"\");\n        require(success, \"Error while sending ETH.\");\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/mocks/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: No-License\npragma solidity 0.8.17;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"hardhat/console.sol\";\n\ncontract PriceFeed {\n    address internal owner;\n    mapping(address => AggregatorV3Interface) internal priceFeeds;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"Only the owner of this smart contract can execute this action.\"\n        );\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function addAssetOracle(address _asset, address _oracle)\n        external\n        onlyOwner\n    {\n        priceFeeds[_asset] = AggregatorV3Interface(_oracle);\n    }\n\n    function getAssetPrice(address _asset) external view returns (uint256) {\n        (, int256 price, , , ) = priceFeeds[_asset].latestRoundData();\n        return uint256(price);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}